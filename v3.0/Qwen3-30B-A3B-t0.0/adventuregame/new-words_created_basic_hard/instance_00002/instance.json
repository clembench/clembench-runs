{
  "game_id": 2,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can latory, tedne, derman, tuate, chross and sulphy.\n\nYour goal for this game is: Make the tulacy enerk, the menny soriced and the ortid alism.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(reele1,penol1)",
    "at(inging1,micon1)",
    "at(menny1,catint1)",
    "at(rist1,catint1)",
    "at(sioust1,catint1)",
    "at(pacia1,catint1)",
    "at(unflued1,catint1)",
    "at(tulacy1,fress1)",
    "at(uncest1,penol1)",
    "at(ortid1,catint1)",
    "at(player1,catint1)",
    "type(player1,player)",
    "type(ortid1,ortid)",
    "type(uncest1,uncest)",
    "type(tulacy1,tulacy)",
    "type(unflued1,unflued)",
    "type(pacia1,pacia)",
    "type(sioust1,sioust)",
    "type(rist1,rist)",
    "type(menny1,menny)",
    "type(inging1,inging)",
    "type(reele1,reele)",
    "room(penol1,penol)",
    "room(micon1,micon)",
    "room(fress1,fress)",
    "room(catint1,catint)",
    "enerk(inging1)",
    "enerk(rist1)",
    "enerk(sioust1)",
    "enerk(pacia1)",
    "prustic(unflued1)",
    "prustic(tulacy1)",
    "soriced(reele1)",
    "logal(unflued1)",
    "ramiced(menny1)",
    "exit(penol1,micon1)",
    "exit(micon1,penol1)",
    "exit(fress1,micon1)",
    "exit(catint1,penol1)",
    "exit(penol1,catint1)",
    "exit(micon1,fress1)",
    "alism_able(ortid1)",
    "alism_able(uncest1)",
    "alism_able(tulacy1)",
    "alism_able(pacia1)",
    "alism_able(menny1)",
    "alism_able(inging1)",
    "enerk_able(tulacy1)",
    "enerk_able(unflued1)",
    "enerk_able(pacia1)",
    "enerk_able(sioust1)",
    "enerk_able(rist1)",
    "enerk_able(inging1)",
    "soriced_able(unflued1)",
    "soriced_able(menny1)",
    "soriced_able(reele1)"
  ],
  "goal_state": [
    "alism(ortid1)",
    "enerk(tulacy1)",
    "soriced(menny1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "sulphy",
      "ortid1"
    ],
    [
      "latory",
      "menny1"
    ],
    [
      "go",
      "penol1"
    ],
    [
      "go",
      "micon1"
    ],
    [
      "go",
      "fress1"
    ],
    [
      "tedne",
      "tulacy1"
    ]
  ],
  "optimal_commands": [
    "sulphy ortid",
    "latory menny",
    "go penol",
    "go micon",
    "go fress",
    "tedne tulacy"
  ],
  "action_definitions": [
    {
      "lark": "sulphy: SULPHY thing\nSULPHY.1: \"sulphy\" WS",
      "pddl": "(:action SULPHY\n    :parameters (?e - alism_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (alism ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not alism-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now alism.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To sulphy is to make something alism_able alism.",
      "asp": "{ action_t(TURN,sulphy,THING):at_t(TURN,THING,ROOM),alism_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nalism_t(TURN+1,THING) :- action_t(TURN,sulphy,THING).\nalism_t(TURN+1,THING) :- turn(TURN), alism_t(TURN,THING).",
      "type_name": "sulphy"
    },
    {
      "lark": "derman: DERMAN thing\nDERMAN.1: \"derman\" WS",
      "pddl": "(:action DERMAN\n    :parameters (?e - enerk_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (enerk ?e)\n        )\n    :effect (and\n        (prustic ?e)\n        (not (enerk ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not enerk-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not enerk.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now prustic.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To derman is to make something enerk_able and enerk be prustic.",
      "asp": "{ action_t(TURN,derman,THING):at_t(TURN,THING,ROOM),enerk_able(THING),enerk_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nprustic_t(TURN+1,THING) :- action_t(TURN,derman,THING).\nenerk_t(TURN+1,THING) :- turn(TURN), enerk_t(TURN,THING), not action_t(TURN,derman,THING).",
      "type_name": "derman"
    },
    {
      "lark": "tedne: TEDNE thing\nTEDNE.1: \"tedne\" WS",
      "pddl": "(:action TEDNE\n    :parameters (?e - enerk_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (prustic ?e)\n        )\n    :effect (and\n        (enerk ?e)\n        (not (prustic ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not enerk-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not prustic.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now enerk.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To tedne is to make something enerk_able and prustic be enerk.",
      "asp": "{ action_t(TURN,tedne,THING):at_t(TURN,THING,ROOM),enerk_able(THING),prustic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nenerk_t(TURN+1,THING) :- action_t(TURN,tedne,THING).\nprustic_t(TURN+1,THING) :- turn(TURN), prustic_t(TURN,THING), not action_t(TURN,tedne,THING).",
      "type_name": "tedne"
    },
    {
      "lark": "tuate: TUATE thing\nTUATE.1: \"tuate\" WS",
      "pddl": "(:action TUATE\n    :parameters (?e - soriced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (soriced ?e)\n        )\n    :effect (and\n        (logal ?e)\n        (not (soriced ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not soriced-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not soriced.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now logal.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To tuate is to make something soriced_able and soriced be logal.",
      "asp": "{ action_t(TURN,tuate,THING):at_t(TURN,THING,ROOM),soriced_able(THING),soriced_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nlogal_t(TURN+1,THING) :- action_t(TURN,tuate,THING).\nsoriced_t(TURN+1,THING) :- turn(TURN), soriced_t(TURN,THING), not action_t(TURN,tuate,THING).",
      "type_name": "tuate"
    },
    {
      "lark": "chross: CHROSS thing\nCHROSS.1: \"chross\" WS",
      "pddl": "(:action CHROSS\n    :parameters (?e - soriced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (logal ?e)\n        )\n    :effect (and\n        (ramiced ?e)\n        (not (logal ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not soriced-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not logal.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ramiced.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To chross is to make something soriced_able and logal be ramiced.",
      "asp": "{ action_t(TURN,chross,THING):at_t(TURN,THING,ROOM),soriced_able(THING),logal_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nramiced_t(TURN+1,THING) :- action_t(TURN,chross,THING).\nlogal_t(TURN+1,THING) :- turn(TURN), logal_t(TURN,THING), not action_t(TURN,chross,THING).",
      "type_name": "chross"
    },
    {
      "lark": "latory: LATORY thing\nLATORY.1: \"latory\" WS",
      "pddl": "(:action LATORY\n    :parameters (?e - soriced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ramiced ?e)\n        )\n    :effect (and\n        (soriced ?e)\n        (not (ramiced ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not soriced-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not ramiced.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now soriced.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To latory is to make something soriced_able and ramiced be soriced.",
      "asp": "{ action_t(TURN,latory,THING):at_t(TURN,THING,ROOM),soriced_able(THING),ramiced_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nsoriced_t(TURN+1,THING) :- action_t(TURN,latory,THING).\nramiced_t(TURN+1,THING) :- turn(TURN), ramiced_t(TURN,THING), not action_t(TURN,latory,THING).",
      "type_name": "latory"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "penol",
      "exit_targets": [
        "fress",
        "micon"
      ],
      "max_connections": 1,
      "type_name": "penol"
    },
    {
      "repr_str": "micon",
      "exit_targets": [
        "penol"
      ],
      "max_connections": 3,
      "type_name": "micon"
    },
    {
      "repr_str": "fress",
      "exit_targets": [
        "micon",
        "catint"
      ],
      "max_connections": 2,
      "type_name": "fress"
    },
    {
      "repr_str": "catint",
      "exit_targets": [
        "fress",
        "micon",
        "penol"
      ],
      "max_connections": 2,
      "type_name": "catint"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "ortid",
      "traits": [
        "alism_able"
      ],
      "standard_locations": [
        "micon",
        "catint"
      ],
      "type_name": "ortid"
    },
    {
      "repr_str": "uncest",
      "traits": [
        "alism_able"
      ],
      "standard_locations": [
        "penol"
      ],
      "type_name": "uncest"
    },
    {
      "repr_str": "tulacy",
      "traits": [
        "enerk_able",
        "alism_able"
      ],
      "standard_locations": [
        "catint",
        "fress"
      ],
      "type_name": "tulacy"
    },
    {
      "repr_str": "unflued",
      "traits": [
        "enerk_able",
        "soriced_able"
      ],
      "standard_locations": [
        "catint"
      ],
      "type_name": "unflued"
    },
    {
      "repr_str": "pacia",
      "traits": [
        "enerk_able",
        "alism_able"
      ],
      "standard_locations": [
        "catint",
        "micon"
      ],
      "type_name": "pacia"
    },
    {
      "repr_str": "sioust",
      "traits": [
        "enerk_able"
      ],
      "standard_locations": [
        "penol",
        "catint"
      ],
      "type_name": "sioust"
    },
    {
      "repr_str": "rist",
      "traits": [
        "enerk_able"
      ],
      "standard_locations": [
        "catint"
      ],
      "type_name": "rist"
    },
    {
      "repr_str": "menny",
      "traits": [
        "soriced_able",
        "alism_able"
      ],
      "standard_locations": [
        "catint"
      ],
      "type_name": "menny"
    },
    {
      "repr_str": "inging",
      "traits": [
        "alism_able",
        "enerk_able"
      ],
      "standard_locations": [
        "micon"
      ],
      "type_name": "inging"
    },
    {
      "repr_str": "reele",
      "traits": [
        "soriced_able"
      ],
      "standard_locations": [
        "penol",
        "fress"
      ],
      "type_name": "reele"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "penol",
          "micon",
          "fress",
          "catint"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "ortid",
          "uncest",
          "tulacy",
          "unflued",
          "pacia",
          "sioust",
          "rist",
          "menny",
          "inging",
          "reele",
          "player",
          "inventory",
          "floor"
        ],
        "alism_able": [
          "ortid",
          "uncest",
          "tulacy",
          "pacia",
          "menny",
          "inging"
        ],
        "enerk_able": [
          "tulacy",
          "unflued",
          "pacia",
          "sioust",
          "rist",
          "inging"
        ],
        "soriced_able": [
          "unflued",
          "menny",
          "reele"
        ]
      },
      "predicates": [
        {
          "predicate_id": "alism",
          "variable": "e",
          "mutability": "alism_able"
        },
        {
          "predicate_id": "enerk",
          "variable": "e",
          "mutability": "enerk_able"
        },
        {
          "predicate_id": "prustic",
          "variable": "e",
          "mutability": "enerk_able"
        },
        {
          "predicate_id": "soriced",
          "variable": "e",
          "mutability": "soriced_able"
        },
        {
          "predicate_id": "logal",
          "variable": "e",
          "mutability": "soriced_able"
        },
        {
          "predicate_id": "ramiced",
          "variable": "e",
          "mutability": "soriced_able"
        }
      ]
    }
  ]
}