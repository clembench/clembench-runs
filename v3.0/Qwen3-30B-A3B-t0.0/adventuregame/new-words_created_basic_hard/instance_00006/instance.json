{
  "game_id": 6,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can bioch, snemic, intess, emood, oustion and erson.\n\nYour goal for this game is: Make the torhy padery, the rot lotta and the astable preciny.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(rialiced1,ram1)",
    "at(ilitid1,stingly1)",
    "at(torhy1,iscum1)",
    "at(tisof1,iscum1)",
    "at(hirry1,iscum1)",
    "at(ishing1,iscum1)",
    "at(lonon1,iscum1)",
    "at(rot1,atoust1)",
    "at(omante1,ram1)",
    "at(astable1,iscum1)",
    "at(player1,iscum1)",
    "type(player1,player)",
    "type(astable1,astable)",
    "type(omante1,omante)",
    "type(rot1,rot)",
    "type(lonon1,lonon)",
    "type(ishing1,ishing)",
    "type(hirry1,hirry)",
    "type(tisof1,tisof)",
    "type(torhy1,torhy)",
    "type(ilitid1,ilitid)",
    "type(rialiced1,rialiced)",
    "room(ram1,ram)",
    "room(stingly1,stingly)",
    "room(atoust1,atoust)",
    "room(iscum1,iscum)",
    "lotta(ilitid1)",
    "lotta(tisof1)",
    "lotta(hirry1)",
    "lotta(ishing1)",
    "gumary(lonon1)",
    "gumary(rot1)",
    "padery(rialiced1)",
    "antally(lonon1)",
    "helum(torhy1)",
    "exit(ram1,stingly1)",
    "exit(stingly1,ram1)",
    "exit(atoust1,stingly1)",
    "exit(iscum1,ram1)",
    "exit(ram1,iscum1)",
    "exit(stingly1,atoust1)",
    "preciny_able(astable1)",
    "preciny_able(omante1)",
    "preciny_able(rot1)",
    "preciny_able(ishing1)",
    "preciny_able(torhy1)",
    "preciny_able(ilitid1)",
    "lotta_able(rot1)",
    "lotta_able(lonon1)",
    "lotta_able(ishing1)",
    "lotta_able(hirry1)",
    "lotta_able(tisof1)",
    "lotta_able(ilitid1)",
    "padery_able(lonon1)",
    "padery_able(torhy1)",
    "padery_able(rialiced1)"
  ],
  "goal_state": [
    "preciny(astable1)",
    "lotta(rot1)",
    "padery(torhy1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "bioch",
      "astable1"
    ],
    [
      "emood",
      "torhy1"
    ],
    [
      "go",
      "ram1"
    ],
    [
      "go",
      "stingly1"
    ],
    [
      "go",
      "atoust1"
    ],
    [
      "snemic",
      "rot1"
    ]
  ],
  "optimal_commands": [
    "bioch astable",
    "emood torhy",
    "go ram",
    "go stingly",
    "go atoust",
    "snemic rot"
  ],
  "action_definitions": [
    {
      "lark": "bioch: BIOCH thing\nBIOCH.1: \"bioch\" WS",
      "pddl": "(:action BIOCH\n    :parameters (?e - preciny_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (preciny ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not preciny-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now preciny.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To bioch is to make something preciny_able preciny.",
      "asp": "{ action_t(TURN,bioch,THING):at_t(TURN,THING,ROOM),preciny_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npreciny_t(TURN+1,THING) :- action_t(TURN,bioch,THING).\npreciny_t(TURN+1,THING) :- turn(TURN), preciny_t(TURN,THING).",
      "type_name": "bioch"
    },
    {
      "lark": "erson: ERSON thing\nERSON.1: \"erson\" WS",
      "pddl": "(:action ERSON\n    :parameters (?e - lotta_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (lotta ?e)\n        )\n    :effect (and\n        (gumary ?e)\n        (not (lotta ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not lotta-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not lotta.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now gumary.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To erson is to make something lotta_able and lotta be gumary.",
      "asp": "{ action_t(TURN,erson,THING):at_t(TURN,THING,ROOM),lotta_able(THING),lotta_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ngumary_t(TURN+1,THING) :- action_t(TURN,erson,THING).\nlotta_t(TURN+1,THING) :- turn(TURN), lotta_t(TURN,THING), not action_t(TURN,erson,THING).",
      "type_name": "erson"
    },
    {
      "lark": "snemic: SNEMIC thing\nSNEMIC.1: \"snemic\" WS",
      "pddl": "(:action SNEMIC\n    :parameters (?e - lotta_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (gumary ?e)\n        )\n    :effect (and\n        (lotta ?e)\n        (not (gumary ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not lotta-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not gumary.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now lotta.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To snemic is to make something lotta_able and gumary be lotta.",
      "asp": "{ action_t(TURN,snemic,THING):at_t(TURN,THING,ROOM),lotta_able(THING),gumary_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nlotta_t(TURN+1,THING) :- action_t(TURN,snemic,THING).\ngumary_t(TURN+1,THING) :- turn(TURN), gumary_t(TURN,THING), not action_t(TURN,snemic,THING).",
      "type_name": "snemic"
    },
    {
      "lark": "intess: INTESS thing\nINTESS.1: \"intess\" WS",
      "pddl": "(:action INTESS\n    :parameters (?e - padery_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (padery ?e)\n        )\n    :effect (and\n        (antally ?e)\n        (not (padery ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not padery-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not padery.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now antally.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To intess is to make something padery_able and padery be antally.",
      "asp": "{ action_t(TURN,intess,THING):at_t(TURN,THING,ROOM),padery_able(THING),padery_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nantally_t(TURN+1,THING) :- action_t(TURN,intess,THING).\npadery_t(TURN+1,THING) :- turn(TURN), padery_t(TURN,THING), not action_t(TURN,intess,THING).",
      "type_name": "intess"
    },
    {
      "lark": "oustion: OUSTION thing\nOUSTION.1: \"oustion\" WS",
      "pddl": "(:action OUSTION\n    :parameters (?e - padery_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (antally ?e)\n        )\n    :effect (and\n        (helum ?e)\n        (not (antally ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not padery-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not antally.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now helum.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To oustion is to make something padery_able and antally be helum.",
      "asp": "{ action_t(TURN,oustion,THING):at_t(TURN,THING,ROOM),padery_able(THING),antally_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhelum_t(TURN+1,THING) :- action_t(TURN,oustion,THING).\nantally_t(TURN+1,THING) :- turn(TURN), antally_t(TURN,THING), not action_t(TURN,oustion,THING).",
      "type_name": "oustion"
    },
    {
      "lark": "emood: EMOOD thing\nEMOOD.1: \"emood\" WS",
      "pddl": "(:action EMOOD\n    :parameters (?e - padery_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (helum ?e)\n        )\n    :effect (and\n        (padery ?e)\n        (not (helum ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not padery-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not helum.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now padery.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To emood is to make something padery_able and helum be padery.",
      "asp": "{ action_t(TURN,emood,THING):at_t(TURN,THING,ROOM),padery_able(THING),helum_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npadery_t(TURN+1,THING) :- action_t(TURN,emood,THING).\nhelum_t(TURN+1,THING) :- turn(TURN), helum_t(TURN,THING), not action_t(TURN,emood,THING).",
      "type_name": "emood"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "ram",
      "exit_targets": [
        "atoust",
        "stingly"
      ],
      "max_connections": 1,
      "type_name": "ram"
    },
    {
      "repr_str": "stingly",
      "exit_targets": [
        "ram"
      ],
      "max_connections": 3,
      "type_name": "stingly"
    },
    {
      "repr_str": "atoust",
      "exit_targets": [
        "stingly",
        "iscum"
      ],
      "max_connections": 2,
      "type_name": "atoust"
    },
    {
      "repr_str": "iscum",
      "exit_targets": [
        "atoust",
        "stingly",
        "ram"
      ],
      "max_connections": 2,
      "type_name": "iscum"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "astable",
      "traits": [
        "preciny_able"
      ],
      "standard_locations": [
        "stingly",
        "iscum"
      ],
      "type_name": "astable"
    },
    {
      "repr_str": "omante",
      "traits": [
        "preciny_able"
      ],
      "standard_locations": [
        "ram"
      ],
      "type_name": "omante"
    },
    {
      "repr_str": "rot",
      "traits": [
        "lotta_able",
        "preciny_able"
      ],
      "standard_locations": [
        "iscum",
        "atoust"
      ],
      "type_name": "rot"
    },
    {
      "repr_str": "lonon",
      "traits": [
        "lotta_able",
        "padery_able"
      ],
      "standard_locations": [
        "iscum"
      ],
      "type_name": "lonon"
    },
    {
      "repr_str": "ishing",
      "traits": [
        "lotta_able",
        "preciny_able"
      ],
      "standard_locations": [
        "iscum",
        "stingly"
      ],
      "type_name": "ishing"
    },
    {
      "repr_str": "hirry",
      "traits": [
        "lotta_able"
      ],
      "standard_locations": [
        "ram",
        "iscum"
      ],
      "type_name": "hirry"
    },
    {
      "repr_str": "tisof",
      "traits": [
        "lotta_able"
      ],
      "standard_locations": [
        "iscum"
      ],
      "type_name": "tisof"
    },
    {
      "repr_str": "torhy",
      "traits": [
        "padery_able",
        "preciny_able"
      ],
      "standard_locations": [
        "iscum"
      ],
      "type_name": "torhy"
    },
    {
      "repr_str": "ilitid",
      "traits": [
        "preciny_able",
        "lotta_able"
      ],
      "standard_locations": [
        "stingly"
      ],
      "type_name": "ilitid"
    },
    {
      "repr_str": "rialiced",
      "traits": [
        "padery_able"
      ],
      "standard_locations": [
        "ram",
        "atoust"
      ],
      "type_name": "rialiced"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "ram",
          "stingly",
          "atoust",
          "iscum"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "astable",
          "omante",
          "rot",
          "lonon",
          "ishing",
          "hirry",
          "tisof",
          "torhy",
          "ilitid",
          "rialiced",
          "player",
          "inventory",
          "floor"
        ],
        "preciny_able": [
          "astable",
          "omante",
          "rot",
          "ishing",
          "torhy",
          "ilitid"
        ],
        "lotta_able": [
          "rot",
          "lonon",
          "ishing",
          "hirry",
          "tisof",
          "ilitid"
        ],
        "padery_able": [
          "lonon",
          "torhy",
          "rialiced"
        ]
      },
      "predicates": [
        {
          "predicate_id": "preciny",
          "variable": "e",
          "mutability": "preciny_able"
        },
        {
          "predicate_id": "lotta",
          "variable": "e",
          "mutability": "lotta_able"
        },
        {
          "predicate_id": "gumary",
          "variable": "e",
          "mutability": "lotta_able"
        },
        {
          "predicate_id": "padery",
          "variable": "e",
          "mutability": "padery_able"
        },
        {
          "predicate_id": "antally",
          "variable": "e",
          "mutability": "padery_able"
        },
        {
          "predicate_id": "helum",
          "variable": "e",
          "mutability": "padery_able"
        }
      ]
    }
  ]
}