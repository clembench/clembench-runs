{
  "game_id": 3,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can seash, andect, lotis, belity, irear and deint.\n\nYour goal for this game is: Make the prolly lingly, the proark incry and the acion arliced.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(dermin1,comper1)",
    "at(intler1,comess1)",
    "at(prolly1,distral1)",
    "at(rabish1,distral1)",
    "at(hypner1,distral1)",
    "at(shness1,distral1)",
    "at(arger1,distral1)",
    "at(acion1,atent1)",
    "at(evism1,comper1)",
    "at(proark1,distral1)",
    "at(player1,distral1)",
    "type(player1,player)",
    "type(proark1,proark)",
    "type(evism1,evism)",
    "type(acion1,acion)",
    "type(arger1,arger)",
    "type(shness1,shness)",
    "type(hypner1,hypner)",
    "type(rabish1,rabish)",
    "type(prolly1,prolly)",
    "type(intler1,intler)",
    "type(dermin1,dermin)",
    "room(comper1,comper)",
    "room(comess1,comess)",
    "room(atent1,atent)",
    "room(distral1,distral)",
    "arliced(intler1)",
    "arliced(rabish1)",
    "arliced(hypner1)",
    "arliced(shness1)",
    "roply(arger1)",
    "roply(acion1)",
    "lingly(dermin1)",
    "riat(arger1)",
    "psessy(prolly1)",
    "exit(comper1,comess1)",
    "exit(comess1,comper1)",
    "exit(atent1,comess1)",
    "exit(distral1,comper1)",
    "exit(comper1,distral1)",
    "exit(comess1,atent1)",
    "incry_able(proark1)",
    "incry_able(evism1)",
    "incry_able(acion1)",
    "incry_able(shness1)",
    "incry_able(prolly1)",
    "incry_able(intler1)",
    "arliced_able(acion1)",
    "arliced_able(arger1)",
    "arliced_able(shness1)",
    "arliced_able(hypner1)",
    "arliced_able(rabish1)",
    "arliced_able(intler1)",
    "lingly_able(arger1)",
    "lingly_able(prolly1)",
    "lingly_able(dermin1)"
  ],
  "goal_state": [
    "incry(proark1)",
    "arliced(acion1)",
    "lingly(prolly1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "deint",
      "proark1"
    ],
    [
      "lotis",
      "prolly1"
    ],
    [
      "go",
      "comper1"
    ],
    [
      "go",
      "comess1"
    ],
    [
      "go",
      "atent1"
    ],
    [
      "irear",
      "acion1"
    ]
  ],
  "optimal_commands": [
    "deint proark",
    "lotis prolly",
    "go comper",
    "go comess",
    "go atent",
    "irear acion"
  ],
  "action_definitions": [
    {
      "lark": "deint: DEINT thing\nDEINT.1: \"deint\" WS",
      "pddl": "(:action DEINT\n    :parameters (?e - incry_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (incry ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not incry-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now incry.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To deint is to make something incry_able incry.",
      "asp": "{ action_t(TURN,deint,THING):at_t(TURN,THING,ROOM),incry_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nincry_t(TURN+1,THING) :- action_t(TURN,deint,THING).\nincry_t(TURN+1,THING) :- turn(TURN), incry_t(TURN,THING).",
      "type_name": "deint"
    },
    {
      "lark": "seash: SEASH thing\nSEASH.1: \"seash\" WS",
      "pddl": "(:action SEASH\n    :parameters (?e - arliced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (arliced ?e)\n        )\n    :effect (and\n        (roply ?e)\n        (not (arliced ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not arliced-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not arliced.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now roply.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To seash is to make something arliced_able and arliced be roply.",
      "asp": "{ action_t(TURN,seash,THING):at_t(TURN,THING,ROOM),arliced_able(THING),arliced_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nroply_t(TURN+1,THING) :- action_t(TURN,seash,THING).\narliced_t(TURN+1,THING) :- turn(TURN), arliced_t(TURN,THING), not action_t(TURN,seash,THING).",
      "type_name": "seash"
    },
    {
      "lark": "irear: IREAR thing\nIREAR.1: \"irear\" WS",
      "pddl": "(:action IREAR\n    :parameters (?e - arliced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (roply ?e)\n        )\n    :effect (and\n        (arliced ?e)\n        (not (roply ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not arliced-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not roply.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now arliced.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To irear is to make something arliced_able and roply be arliced.",
      "asp": "{ action_t(TURN,irear,THING):at_t(TURN,THING,ROOM),arliced_able(THING),roply_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\narliced_t(TURN+1,THING) :- action_t(TURN,irear,THING).\nroply_t(TURN+1,THING) :- turn(TURN), roply_t(TURN,THING), not action_t(TURN,irear,THING).",
      "type_name": "irear"
    },
    {
      "lark": "belity: BELITY thing\nBELITY.1: \"belity\" WS",
      "pddl": "(:action BELITY\n    :parameters (?e - lingly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (lingly ?e)\n        )\n    :effect (and\n        (riat ?e)\n        (not (lingly ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not lingly-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not lingly.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now riat.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To belity is to make something lingly_able and lingly be riat.",
      "asp": "{ action_t(TURN,belity,THING):at_t(TURN,THING,ROOM),lingly_able(THING),lingly_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nriat_t(TURN+1,THING) :- action_t(TURN,belity,THING).\nlingly_t(TURN+1,THING) :- turn(TURN), lingly_t(TURN,THING), not action_t(TURN,belity,THING).",
      "type_name": "belity"
    },
    {
      "lark": "andect: ANDECT thing\nANDECT.1: \"andect\" WS",
      "pddl": "(:action ANDECT\n    :parameters (?e - lingly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (riat ?e)\n        )\n    :effect (and\n        (psessy ?e)\n        (not (riat ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not lingly-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not riat.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now psessy.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To andect is to make something lingly_able and riat be psessy.",
      "asp": "{ action_t(TURN,andect,THING):at_t(TURN,THING,ROOM),lingly_able(THING),riat_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npsessy_t(TURN+1,THING) :- action_t(TURN,andect,THING).\nriat_t(TURN+1,THING) :- turn(TURN), riat_t(TURN,THING), not action_t(TURN,andect,THING).",
      "type_name": "andect"
    },
    {
      "lark": "lotis: LOTIS thing\nLOTIS.1: \"lotis\" WS",
      "pddl": "(:action LOTIS\n    :parameters (?e - lingly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (psessy ?e)\n        )\n    :effect (and\n        (lingly ?e)\n        (not (psessy ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not lingly-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not psessy.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now lingly.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To lotis is to make something lingly_able and psessy be lingly.",
      "asp": "{ action_t(TURN,lotis,THING):at_t(TURN,THING,ROOM),lingly_able(THING),psessy_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nlingly_t(TURN+1,THING) :- action_t(TURN,lotis,THING).\npsessy_t(TURN+1,THING) :- turn(TURN), psessy_t(TURN,THING), not action_t(TURN,lotis,THING).",
      "type_name": "lotis"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "comper",
      "exit_targets": [
        "atent",
        "comess"
      ],
      "max_connections": 1,
      "type_name": "comper"
    },
    {
      "repr_str": "comess",
      "exit_targets": [
        "comper"
      ],
      "max_connections": 3,
      "type_name": "comess"
    },
    {
      "repr_str": "atent",
      "exit_targets": [
        "comess",
        "distral"
      ],
      "max_connections": 2,
      "type_name": "atent"
    },
    {
      "repr_str": "distral",
      "exit_targets": [
        "atent",
        "comess",
        "comper"
      ],
      "max_connections": 2,
      "type_name": "distral"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "proark",
      "traits": [
        "incry_able"
      ],
      "standard_locations": [
        "comess",
        "distral"
      ],
      "type_name": "proark"
    },
    {
      "repr_str": "evism",
      "traits": [
        "incry_able"
      ],
      "standard_locations": [
        "comper"
      ],
      "type_name": "evism"
    },
    {
      "repr_str": "acion",
      "traits": [
        "arliced_able",
        "incry_able"
      ],
      "standard_locations": [
        "distral",
        "atent"
      ],
      "type_name": "acion"
    },
    {
      "repr_str": "arger",
      "traits": [
        "arliced_able",
        "lingly_able"
      ],
      "standard_locations": [
        "distral"
      ],
      "type_name": "arger"
    },
    {
      "repr_str": "shness",
      "traits": [
        "arliced_able",
        "incry_able"
      ],
      "standard_locations": [
        "distral",
        "comess"
      ],
      "type_name": "shness"
    },
    {
      "repr_str": "hypner",
      "traits": [
        "arliced_able"
      ],
      "standard_locations": [
        "comper",
        "distral"
      ],
      "type_name": "hypner"
    },
    {
      "repr_str": "rabish",
      "traits": [
        "arliced_able"
      ],
      "standard_locations": [
        "distral"
      ],
      "type_name": "rabish"
    },
    {
      "repr_str": "prolly",
      "traits": [
        "lingly_able",
        "incry_able"
      ],
      "standard_locations": [
        "distral"
      ],
      "type_name": "prolly"
    },
    {
      "repr_str": "intler",
      "traits": [
        "incry_able",
        "arliced_able"
      ],
      "standard_locations": [
        "comess"
      ],
      "type_name": "intler"
    },
    {
      "repr_str": "dermin",
      "traits": [
        "lingly_able"
      ],
      "standard_locations": [
        "comper",
        "atent"
      ],
      "type_name": "dermin"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "comper",
          "comess",
          "atent",
          "distral"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "proark",
          "evism",
          "acion",
          "arger",
          "shness",
          "hypner",
          "rabish",
          "prolly",
          "intler",
          "dermin",
          "player",
          "inventory",
          "floor"
        ],
        "incry_able": [
          "proark",
          "evism",
          "acion",
          "shness",
          "prolly",
          "intler"
        ],
        "arliced_able": [
          "acion",
          "arger",
          "shness",
          "hypner",
          "rabish",
          "intler"
        ],
        "lingly_able": [
          "arger",
          "prolly",
          "dermin"
        ]
      },
      "predicates": [
        {
          "predicate_id": "incry",
          "variable": "e",
          "mutability": "incry_able"
        },
        {
          "predicate_id": "arliced",
          "variable": "e",
          "mutability": "arliced_able"
        },
        {
          "predicate_id": "roply",
          "variable": "e",
          "mutability": "arliced_able"
        },
        {
          "predicate_id": "lingly",
          "variable": "e",
          "mutability": "lingly_able"
        },
        {
          "predicate_id": "riat",
          "variable": "e",
          "mutability": "lingly_able"
        },
        {
          "predicate_id": "psessy",
          "variable": "e",
          "mutability": "lingly_able"
        }
      ]
    }
  ]
}