{
  "game_id": 1,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can delly, heted, ousne, unalin, thoty and ceous.\n\nYour goal for this game is: Make the secti unpish, the rably nolog and the imped atory.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(nogia1,uner1)",
    "at(trionee1,natin1)",
    "at(rably1,perced1)",
    "at(stism1,perced1)",
    "at(torish1,perced1)",
    "at(inet1,perced1)",
    "at(nond1,perced1)",
    "at(imped1,trion1)",
    "at(trateler1,uner1)",
    "at(secti1,perced1)",
    "at(player1,perced1)",
    "type(player1,player)",
    "type(secti1,secti)",
    "type(trateler1,trateler)",
    "type(imped1,imped)",
    "type(nond1,nond)",
    "type(inet1,inet)",
    "type(torish1,torish)",
    "type(stism1,stism)",
    "type(rably1,rably)",
    "type(trionee1,trionee)",
    "type(nogia1,nogia)",
    "room(uner1,uner)",
    "room(natin1,natin)",
    "room(trion1,trion)",
    "room(perced1,perced)",
    "atory(trionee1)",
    "atory(stism1)",
    "atory(torish1)",
    "atory(inet1)",
    "aling(nond1)",
    "aling(imped1)",
    "nolog(nogia1)",
    "vater(nond1)",
    "atione(rably1)",
    "exit(uner1,natin1)",
    "exit(natin1,uner1)",
    "exit(trion1,natin1)",
    "exit(perced1,uner1)",
    "exit(uner1,perced1)",
    "exit(natin1,trion1)",
    "unpish_able(secti1)",
    "unpish_able(trateler1)",
    "unpish_able(imped1)",
    "unpish_able(inet1)",
    "unpish_able(rably1)",
    "unpish_able(trionee1)",
    "atory_able(imped1)",
    "atory_able(nond1)",
    "atory_able(inet1)",
    "atory_able(torish1)",
    "atory_able(stism1)",
    "atory_able(trionee1)",
    "nolog_able(nond1)",
    "nolog_able(rably1)",
    "nolog_able(nogia1)"
  ],
  "goal_state": [
    "unpish(secti1)",
    "atory(imped1)",
    "nolog(rably1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "ousne",
      "secti1"
    ],
    [
      "ceous",
      "rably1"
    ],
    [
      "go",
      "uner1"
    ],
    [
      "go",
      "natin1"
    ],
    [
      "go",
      "trion1"
    ],
    [
      "delly",
      "imped1"
    ]
  ],
  "optimal_commands": [
    "ousne secti",
    "ceous rably",
    "go uner",
    "go natin",
    "go trion",
    "delly imped"
  ],
  "action_definitions": [
    {
      "lark": "ousne: OUSNE thing\nOUSNE.1: \"ousne\" WS",
      "pddl": "(:action OUSNE\n    :parameters (?e - unpish_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (unpish ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not unpish-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now unpish.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ousne is to make something unpish_able unpish.",
      "asp": "{ action_t(TURN,ousne,THING):at_t(TURN,THING,ROOM),unpish_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nunpish_t(TURN+1,THING) :- action_t(TURN,ousne,THING).\nunpish_t(TURN+1,THING) :- turn(TURN), unpish_t(TURN,THING).",
      "type_name": "ousne"
    },
    {
      "lark": "heted: HETED thing\nHETED.1: \"heted\" WS",
      "pddl": "(:action HETED\n    :parameters (?e - atory_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (atory ?e)\n        )\n    :effect (and\n        (aling ?e)\n        (not (atory ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not atory-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not atory.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now aling.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To heted is to make something atory_able and atory be aling.",
      "asp": "{ action_t(TURN,heted,THING):at_t(TURN,THING,ROOM),atory_able(THING),atory_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\naling_t(TURN+1,THING) :- action_t(TURN,heted,THING).\natory_t(TURN+1,THING) :- turn(TURN), atory_t(TURN,THING), not action_t(TURN,heted,THING).",
      "type_name": "heted"
    },
    {
      "lark": "delly: DELLY thing\nDELLY.1: \"delly\" WS",
      "pddl": "(:action DELLY\n    :parameters (?e - atory_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (aling ?e)\n        )\n    :effect (and\n        (atory ?e)\n        (not (aling ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not atory-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not aling.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now atory.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To delly is to make something atory_able and aling be atory.",
      "asp": "{ action_t(TURN,delly,THING):at_t(TURN,THING,ROOM),atory_able(THING),aling_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\natory_t(TURN+1,THING) :- action_t(TURN,delly,THING).\naling_t(TURN+1,THING) :- turn(TURN), aling_t(TURN,THING), not action_t(TURN,delly,THING).",
      "type_name": "delly"
    },
    {
      "lark": "unalin: UNALIN thing\nUNALIN.1: \"unalin\" WS",
      "pddl": "(:action UNALIN\n    :parameters (?e - nolog_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (nolog ?e)\n        )\n    :effect (and\n        (vater ?e)\n        (not (nolog ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not nolog-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not nolog.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now vater.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To unalin is to make something nolog_able and nolog be vater.",
      "asp": "{ action_t(TURN,unalin,THING):at_t(TURN,THING,ROOM),nolog_able(THING),nolog_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nvater_t(TURN+1,THING) :- action_t(TURN,unalin,THING).\nnolog_t(TURN+1,THING) :- turn(TURN), nolog_t(TURN,THING), not action_t(TURN,unalin,THING).",
      "type_name": "unalin"
    },
    {
      "lark": "thoty: THOTY thing\nTHOTY.1: \"thoty\" WS",
      "pddl": "(:action THOTY\n    :parameters (?e - nolog_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (vater ?e)\n        )\n    :effect (and\n        (atione ?e)\n        (not (vater ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not nolog-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not vater.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now atione.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To thoty is to make something nolog_able and vater be atione.",
      "asp": "{ action_t(TURN,thoty,THING):at_t(TURN,THING,ROOM),nolog_able(THING),vater_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\natione_t(TURN+1,THING) :- action_t(TURN,thoty,THING).\nvater_t(TURN+1,THING) :- turn(TURN), vater_t(TURN,THING), not action_t(TURN,thoty,THING).",
      "type_name": "thoty"
    },
    {
      "lark": "ceous: CEOUS thing\nCEOUS.1: \"ceous\" WS",
      "pddl": "(:action CEOUS\n    :parameters (?e - nolog_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (atione ?e)\n        )\n    :effect (and\n        (nolog ?e)\n        (not (atione ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not nolog-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not atione.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now nolog.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ceous is to make something nolog_able and atione be nolog.",
      "asp": "{ action_t(TURN,ceous,THING):at_t(TURN,THING,ROOM),nolog_able(THING),atione_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nnolog_t(TURN+1,THING) :- action_t(TURN,ceous,THING).\natione_t(TURN+1,THING) :- turn(TURN), atione_t(TURN,THING), not action_t(TURN,ceous,THING).",
      "type_name": "ceous"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "uner",
      "exit_targets": [
        "trion",
        "natin"
      ],
      "max_connections": 1,
      "type_name": "uner"
    },
    {
      "repr_str": "natin",
      "exit_targets": [
        "uner"
      ],
      "max_connections": 3,
      "type_name": "natin"
    },
    {
      "repr_str": "trion",
      "exit_targets": [
        "natin",
        "perced"
      ],
      "max_connections": 2,
      "type_name": "trion"
    },
    {
      "repr_str": "perced",
      "exit_targets": [
        "trion",
        "natin",
        "uner"
      ],
      "max_connections": 2,
      "type_name": "perced"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "secti",
      "traits": [
        "unpish_able"
      ],
      "standard_locations": [
        "natin",
        "perced"
      ],
      "type_name": "secti"
    },
    {
      "repr_str": "trateler",
      "traits": [
        "unpish_able"
      ],
      "standard_locations": [
        "uner"
      ],
      "type_name": "trateler"
    },
    {
      "repr_str": "imped",
      "traits": [
        "atory_able",
        "unpish_able"
      ],
      "standard_locations": [
        "perced",
        "trion"
      ],
      "type_name": "imped"
    },
    {
      "repr_str": "nond",
      "traits": [
        "atory_able",
        "nolog_able"
      ],
      "standard_locations": [
        "perced"
      ],
      "type_name": "nond"
    },
    {
      "repr_str": "inet",
      "traits": [
        "atory_able",
        "unpish_able"
      ],
      "standard_locations": [
        "perced",
        "natin"
      ],
      "type_name": "inet"
    },
    {
      "repr_str": "torish",
      "traits": [
        "atory_able"
      ],
      "standard_locations": [
        "uner",
        "perced"
      ],
      "type_name": "torish"
    },
    {
      "repr_str": "stism",
      "traits": [
        "atory_able"
      ],
      "standard_locations": [
        "perced"
      ],
      "type_name": "stism"
    },
    {
      "repr_str": "rably",
      "traits": [
        "nolog_able",
        "unpish_able"
      ],
      "standard_locations": [
        "perced"
      ],
      "type_name": "rably"
    },
    {
      "repr_str": "trionee",
      "traits": [
        "unpish_able",
        "atory_able"
      ],
      "standard_locations": [
        "natin"
      ],
      "type_name": "trionee"
    },
    {
      "repr_str": "nogia",
      "traits": [
        "nolog_able"
      ],
      "standard_locations": [
        "uner",
        "trion"
      ],
      "type_name": "nogia"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "uner",
          "natin",
          "trion",
          "perced"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "secti",
          "trateler",
          "imped",
          "nond",
          "inet",
          "torish",
          "stism",
          "rably",
          "trionee",
          "nogia",
          "player",
          "inventory",
          "floor"
        ],
        "unpish_able": [
          "secti",
          "trateler",
          "imped",
          "inet",
          "rably",
          "trionee"
        ],
        "atory_able": [
          "imped",
          "nond",
          "inet",
          "torish",
          "stism",
          "trionee"
        ],
        "nolog_able": [
          "nond",
          "rably",
          "nogia"
        ]
      },
      "predicates": [
        {
          "predicate_id": "unpish",
          "variable": "e",
          "mutability": "unpish_able"
        },
        {
          "predicate_id": "atory",
          "variable": "e",
          "mutability": "atory_able"
        },
        {
          "predicate_id": "aling",
          "variable": "e",
          "mutability": "atory_able"
        },
        {
          "predicate_id": "nolog",
          "variable": "e",
          "mutability": "nolog_able"
        },
        {
          "predicate_id": "vater",
          "variable": "e",
          "mutability": "nolog_able"
        },
        {
          "predicate_id": "atione",
          "variable": "e",
          "mutability": "nolog_able"
        }
      ]
    }
  ]
}