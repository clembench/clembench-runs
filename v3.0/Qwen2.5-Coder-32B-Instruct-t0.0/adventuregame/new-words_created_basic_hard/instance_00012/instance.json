{
  "game_id": 12,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can eredle, unsibion, phophous, isecin, horehet and indiable.\n\nYour goal for this game is: Make the rimess horpler, the urermat ytoust and the loscred tibing.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(ragmat1,gligiced1)",
    "at(entabul1,urgily1)",
    "at(loscred1,discroust1)",
    "at(suncente1,discroust1)",
    "at(eposper1,discroust1)",
    "at(hidist1,discroust1)",
    "at(conitity1,discroust1)",
    "at(rimess1,ibret1)",
    "at(thempary1,gligiced1)",
    "at(urermat1,discroust1)",
    "at(player1,discroust1)",
    "type(player1,player)",
    "type(urermat1,urermat)",
    "type(thempary1,thempary)",
    "type(rimess1,rimess)",
    "type(conitity1,conitity)",
    "type(hidist1,hidist)",
    "type(eposper1,eposper)",
    "type(suncente1,suncente)",
    "type(loscred1,loscred)",
    "type(entabul1,entabul)",
    "type(ragmat1,ragmat)",
    "room(gligiced1,gligiced)",
    "room(urgily1,urgily)",
    "room(ibret1,ibret)",
    "room(discroust1,discroust)",
    "horpler(entabul1)",
    "horpler(suncente1)",
    "horpler(eposper1)",
    "horpler(hidist1)",
    "suatocky(conitity1)",
    "suatocky(rimess1)",
    "tibing(ragmat1)",
    "orposee(conitity1)",
    "oanicky(loscred1)",
    "exit(gligiced1,urgily1)",
    "exit(urgily1,gligiced1)",
    "exit(ibret1,urgily1)",
    "exit(discroust1,gligiced1)",
    "exit(gligiced1,discroust1)",
    "exit(urgily1,ibret1)",
    "ytoust_able(urermat1)",
    "ytoust_able(thempary1)",
    "ytoust_able(rimess1)",
    "ytoust_able(hidist1)",
    "ytoust_able(loscred1)",
    "ytoust_able(entabul1)",
    "horpler_able(rimess1)",
    "horpler_able(conitity1)",
    "horpler_able(hidist1)",
    "horpler_able(eposper1)",
    "horpler_able(suncente1)",
    "horpler_able(entabul1)",
    "tibing_able(conitity1)",
    "tibing_able(loscred1)",
    "tibing_able(ragmat1)"
  ],
  "goal_state": [
    "ytoust(urermat1)",
    "horpler(rimess1)",
    "tibing(loscred1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "eredle",
      "urermat1"
    ],
    [
      "indiable",
      "loscred1"
    ],
    [
      "go",
      "gligiced1"
    ],
    [
      "go",
      "urgily1"
    ],
    [
      "go",
      "ibret1"
    ],
    [
      "phophous",
      "rimess1"
    ]
  ],
  "optimal_commands": [
    "eredle urermat",
    "indiable loscred",
    "go gligiced",
    "go urgily",
    "go ibret",
    "phophous rimess"
  ],
  "action_definitions": [
    {
      "lark": "eredle: EREDLE thing\nEREDLE.1: \"eredle\" WS",
      "pddl": "(:action EREDLE\n    :parameters (?e - ytoust_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (ytoust ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ytoust-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ytoust.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To eredle is to make something ytoust_able ytoust.",
      "asp": "{ action_t(TURN,eredle,THING):at_t(TURN,THING,ROOM),ytoust_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nytoust_t(TURN+1,THING) :- action_t(TURN,eredle,THING).\nytoust_t(TURN+1,THING) :- turn(TURN), ytoust_t(TURN,THING).",
      "type_name": "eredle"
    },
    {
      "lark": "unsibion: UNSIBION thing\nUNSIBION.1: \"unsibion\" WS",
      "pddl": "(:action UNSIBION\n    :parameters (?e - horpler_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (horpler ?e)\n        )\n    :effect (and\n        (suatocky ?e)\n        (not (horpler ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not horpler-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not horpler.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now suatocky.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To unsibion is to make something horpler_able and horpler be suatocky.",
      "asp": "{ action_t(TURN,unsibion,THING):at_t(TURN,THING,ROOM),horpler_able(THING),horpler_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nsuatocky_t(TURN+1,THING) :- action_t(TURN,unsibion,THING).\nhorpler_t(TURN+1,THING) :- turn(TURN), horpler_t(TURN,THING), not action_t(TURN,unsibion,THING).",
      "type_name": "unsibion"
    },
    {
      "lark": "phophous: PHOPHOUS thing\nPHOPHOUS.1: \"phophous\" WS",
      "pddl": "(:action PHOPHOUS\n    :parameters (?e - horpler_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (suatocky ?e)\n        )\n    :effect (and\n        (horpler ?e)\n        (not (suatocky ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not horpler-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not suatocky.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now horpler.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To phophous is to make something horpler_able and suatocky be horpler.",
      "asp": "{ action_t(TURN,phophous,THING):at_t(TURN,THING,ROOM),horpler_able(THING),suatocky_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhorpler_t(TURN+1,THING) :- action_t(TURN,phophous,THING).\nsuatocky_t(TURN+1,THING) :- turn(TURN), suatocky_t(TURN,THING), not action_t(TURN,phophous,THING).",
      "type_name": "phophous"
    },
    {
      "lark": "isecin: ISECIN thing\nISECIN.1: \"isecin\" WS",
      "pddl": "(:action ISECIN\n    :parameters (?e - tibing_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (tibing ?e)\n        )\n    :effect (and\n        (orposee ?e)\n        (not (tibing ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not tibing-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not tibing.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now orposee.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To isecin is to make something tibing_able and tibing be orposee.",
      "asp": "{ action_t(TURN,isecin,THING):at_t(TURN,THING,ROOM),tibing_able(THING),tibing_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\norposee_t(TURN+1,THING) :- action_t(TURN,isecin,THING).\ntibing_t(TURN+1,THING) :- turn(TURN), tibing_t(TURN,THING), not action_t(TURN,isecin,THING).",
      "type_name": "isecin"
    },
    {
      "lark": "horehet: HOREHET thing\nHOREHET.1: \"horehet\" WS",
      "pddl": "(:action HOREHET\n    :parameters (?e - tibing_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (orposee ?e)\n        )\n    :effect (and\n        (oanicky ?e)\n        (not (orposee ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not tibing-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not orposee.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now oanicky.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To horehet is to make something tibing_able and orposee be oanicky.",
      "asp": "{ action_t(TURN,horehet,THING):at_t(TURN,THING,ROOM),tibing_able(THING),orposee_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\noanicky_t(TURN+1,THING) :- action_t(TURN,horehet,THING).\norposee_t(TURN+1,THING) :- turn(TURN), orposee_t(TURN,THING), not action_t(TURN,horehet,THING).",
      "type_name": "horehet"
    },
    {
      "lark": "indiable: INDIABLE thing\nINDIABLE.1: \"indiable\" WS",
      "pddl": "(:action INDIABLE\n    :parameters (?e - tibing_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (oanicky ?e)\n        )\n    :effect (and\n        (tibing ?e)\n        (not (oanicky ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not tibing-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not oanicky.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now tibing.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To indiable is to make something tibing_able and oanicky be tibing.",
      "asp": "{ action_t(TURN,indiable,THING):at_t(TURN,THING,ROOM),tibing_able(THING),oanicky_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntibing_t(TURN+1,THING) :- action_t(TURN,indiable,THING).\noanicky_t(TURN+1,THING) :- turn(TURN), oanicky_t(TURN,THING), not action_t(TURN,indiable,THING).",
      "type_name": "indiable"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "gligiced",
      "exit_targets": [
        "ibret",
        "urgily"
      ],
      "max_connections": 1,
      "type_name": "gligiced"
    },
    {
      "repr_str": "urgily",
      "exit_targets": [
        "gligiced"
      ],
      "max_connections": 3,
      "type_name": "urgily"
    },
    {
      "repr_str": "ibret",
      "exit_targets": [
        "urgily",
        "discroust"
      ],
      "max_connections": 2,
      "type_name": "ibret"
    },
    {
      "repr_str": "discroust",
      "exit_targets": [
        "ibret",
        "urgily",
        "gligiced"
      ],
      "max_connections": 2,
      "type_name": "discroust"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "urermat",
      "traits": [
        "ytoust_able"
      ],
      "standard_locations": [
        "urgily",
        "discroust"
      ],
      "type_name": "urermat"
    },
    {
      "repr_str": "thempary",
      "traits": [
        "ytoust_able"
      ],
      "standard_locations": [
        "gligiced"
      ],
      "type_name": "thempary"
    },
    {
      "repr_str": "rimess",
      "traits": [
        "horpler_able",
        "ytoust_able"
      ],
      "standard_locations": [
        "discroust",
        "ibret"
      ],
      "type_name": "rimess"
    },
    {
      "repr_str": "conitity",
      "traits": [
        "horpler_able",
        "tibing_able"
      ],
      "standard_locations": [
        "discroust"
      ],
      "type_name": "conitity"
    },
    {
      "repr_str": "hidist",
      "traits": [
        "horpler_able",
        "ytoust_able"
      ],
      "standard_locations": [
        "discroust",
        "urgily"
      ],
      "type_name": "hidist"
    },
    {
      "repr_str": "eposper",
      "traits": [
        "horpler_able"
      ],
      "standard_locations": [
        "gligiced",
        "discroust"
      ],
      "type_name": "eposper"
    },
    {
      "repr_str": "suncente",
      "traits": [
        "horpler_able"
      ],
      "standard_locations": [
        "discroust"
      ],
      "type_name": "suncente"
    },
    {
      "repr_str": "loscred",
      "traits": [
        "tibing_able",
        "ytoust_able"
      ],
      "standard_locations": [
        "discroust"
      ],
      "type_name": "loscred"
    },
    {
      "repr_str": "entabul",
      "traits": [
        "ytoust_able",
        "horpler_able"
      ],
      "standard_locations": [
        "urgily"
      ],
      "type_name": "entabul"
    },
    {
      "repr_str": "ragmat",
      "traits": [
        "tibing_able"
      ],
      "standard_locations": [
        "gligiced",
        "ibret"
      ],
      "type_name": "ragmat"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "gligiced",
          "urgily",
          "ibret",
          "discroust"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "urermat",
          "thempary",
          "rimess",
          "conitity",
          "hidist",
          "eposper",
          "suncente",
          "loscred",
          "entabul",
          "ragmat",
          "player",
          "inventory",
          "floor"
        ],
        "ytoust_able": [
          "urermat",
          "thempary",
          "rimess",
          "hidist",
          "loscred",
          "entabul"
        ],
        "horpler_able": [
          "rimess",
          "conitity",
          "hidist",
          "eposper",
          "suncente",
          "entabul"
        ],
        "tibing_able": [
          "conitity",
          "loscred",
          "ragmat"
        ]
      },
      "predicates": [
        {
          "predicate_id": "ytoust",
          "variable": "e",
          "mutability": "ytoust_able"
        },
        {
          "predicate_id": "horpler",
          "variable": "e",
          "mutability": "horpler_able"
        },
        {
          "predicate_id": "suatocky",
          "variable": "e",
          "mutability": "horpler_able"
        },
        {
          "predicate_id": "tibing",
          "variable": "e",
          "mutability": "tibing_able"
        },
        {
          "predicate_id": "orposee",
          "variable": "e",
          "mutability": "tibing_able"
        },
        {
          "predicate_id": "oanicky",
          "variable": "e",
          "mutability": "tibing_able"
        }
      ]
    }
  ]
}