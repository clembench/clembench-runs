{
  "game_id": 15,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can prophedly, lystly, curatily, uncomagol, tationnis and sifoat.\n\nYour goal for this game is: Make the telyphy vatmene, the rogisart pineger and the pienthor exabarb.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(ansubder1,gurlite1)",
    "at(hocyard1,puranity1)",
    "at(rogisart1,caligaticed1)",
    "at(pakably1,caligaticed1)",
    "at(tecural1,caligaticed1)",
    "at(ubdonee1,caligaticed1)",
    "at(aribess1,caligaticed1)",
    "at(telyphy1,redaka1)",
    "at(cophaal1,gurlite1)",
    "at(pienthor1,caligaticed1)",
    "at(player1,caligaticed1)",
    "type(player1,player)",
    "type(pienthor1,pienthor)",
    "type(cophaal1,cophaal)",
    "type(telyphy1,telyphy)",
    "type(aribess1,aribess)",
    "type(ubdonee1,ubdonee)",
    "type(tecural1,tecural)",
    "type(pakably1,pakably)",
    "type(rogisart1,rogisart)",
    "type(hocyard1,hocyard)",
    "type(ansubder1,ansubder)",
    "room(gurlite1,gurlite)",
    "room(puranity1,puranity)",
    "room(redaka1,redaka)",
    "room(caligaticed1,caligaticed)",
    "vatmene(hocyard1)",
    "vatmene(pakably1)",
    "vatmene(tecural1)",
    "vatmene(ubdonee1)",
    "ioblex(aribess1)",
    "ioblex(telyphy1)",
    "pineger(ansubder1)",
    "earatory(aribess1)",
    "onesive(rogisart1)",
    "exit(gurlite1,puranity1)",
    "exit(puranity1,gurlite1)",
    "exit(redaka1,puranity1)",
    "exit(caligaticed1,gurlite1)",
    "exit(gurlite1,caligaticed1)",
    "exit(puranity1,redaka1)",
    "exabarb_able(pienthor1)",
    "exabarb_able(cophaal1)",
    "exabarb_able(telyphy1)",
    "exabarb_able(ubdonee1)",
    "exabarb_able(rogisart1)",
    "exabarb_able(hocyard1)",
    "vatmene_able(telyphy1)",
    "vatmene_able(aribess1)",
    "vatmene_able(ubdonee1)",
    "vatmene_able(tecural1)",
    "vatmene_able(pakably1)",
    "vatmene_able(hocyard1)",
    "pineger_able(aribess1)",
    "pineger_able(rogisart1)",
    "pineger_able(ansubder1)"
  ],
  "goal_state": [
    "exabarb(pienthor1)",
    "vatmene(telyphy1)",
    "pineger(rogisart1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "lystly",
      "pienthor1"
    ],
    [
      "tationnis",
      "rogisart1"
    ],
    [
      "go",
      "gurlite1"
    ],
    [
      "go",
      "puranity1"
    ],
    [
      "go",
      "redaka1"
    ],
    [
      "prophedly",
      "telyphy1"
    ]
  ],
  "optimal_commands": [
    "lystly pienthor",
    "tationnis rogisart",
    "go gurlite",
    "go puranity",
    "go redaka",
    "prophedly telyphy"
  ],
  "action_definitions": [
    {
      "lark": "lystly: LYSTLY thing\nLYSTLY.1: \"lystly\" WS",
      "pddl": "(:action LYSTLY\n    :parameters (?e - exabarb_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (exabarb ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not exabarb-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now exabarb.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To lystly is to make something exabarb_able exabarb.",
      "asp": "{ action_t(TURN,lystly,THING):at_t(TURN,THING,ROOM),exabarb_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nexabarb_t(TURN+1,THING) :- action_t(TURN,lystly,THING).\nexabarb_t(TURN+1,THING) :- turn(TURN), exabarb_t(TURN,THING).",
      "type_name": "lystly"
    },
    {
      "lark": "sifoat: SIFOAT thing\nSIFOAT.1: \"sifoat\" WS",
      "pddl": "(:action SIFOAT\n    :parameters (?e - vatmene_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (vatmene ?e)\n        )\n    :effect (and\n        (ioblex ?e)\n        (not (vatmene ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not vatmene-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not vatmene.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ioblex.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To sifoat is to make something vatmene_able and vatmene be ioblex.",
      "asp": "{ action_t(TURN,sifoat,THING):at_t(TURN,THING,ROOM),vatmene_able(THING),vatmene_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nioblex_t(TURN+1,THING) :- action_t(TURN,sifoat,THING).\nvatmene_t(TURN+1,THING) :- turn(TURN), vatmene_t(TURN,THING), not action_t(TURN,sifoat,THING).",
      "type_name": "sifoat"
    },
    {
      "lark": "prophedly: PROPHEDLY thing\nPROPHEDLY.1: \"prophedly\" WS",
      "pddl": "(:action PROPHEDLY\n    :parameters (?e - vatmene_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ioblex ?e)\n        )\n    :effect (and\n        (vatmene ?e)\n        (not (ioblex ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not vatmene-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not ioblex.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now vatmene.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To prophedly is to make something vatmene_able and ioblex be vatmene.",
      "asp": "{ action_t(TURN,prophedly,THING):at_t(TURN,THING,ROOM),vatmene_able(THING),ioblex_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nvatmene_t(TURN+1,THING) :- action_t(TURN,prophedly,THING).\nioblex_t(TURN+1,THING) :- turn(TURN), ioblex_t(TURN,THING), not action_t(TURN,prophedly,THING).",
      "type_name": "prophedly"
    },
    {
      "lark": "curatily: CURATILY thing\nCURATILY.1: \"curatily\" WS",
      "pddl": "(:action CURATILY\n    :parameters (?e - pineger_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (pineger ?e)\n        )\n    :effect (and\n        (earatory ?e)\n        (not (pineger ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not pineger-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not pineger.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now earatory.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To curatily is to make something pineger_able and pineger be earatory.",
      "asp": "{ action_t(TURN,curatily,THING):at_t(TURN,THING,ROOM),pineger_able(THING),pineger_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nearatory_t(TURN+1,THING) :- action_t(TURN,curatily,THING).\npineger_t(TURN+1,THING) :- turn(TURN), pineger_t(TURN,THING), not action_t(TURN,curatily,THING).",
      "type_name": "curatily"
    },
    {
      "lark": "uncomagol: UNCOMAGOL thing\nUNCOMAGOL.1: \"uncomagol\" WS",
      "pddl": "(:action UNCOMAGOL\n    :parameters (?e - pineger_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (earatory ?e)\n        )\n    :effect (and\n        (onesive ?e)\n        (not (earatory ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not pineger-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not earatory.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now onesive.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To uncomagol is to make something pineger_able and earatory be onesive.",
      "asp": "{ action_t(TURN,uncomagol,THING):at_t(TURN,THING,ROOM),pineger_able(THING),earatory_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nonesive_t(TURN+1,THING) :- action_t(TURN,uncomagol,THING).\nearatory_t(TURN+1,THING) :- turn(TURN), earatory_t(TURN,THING), not action_t(TURN,uncomagol,THING).",
      "type_name": "uncomagol"
    },
    {
      "lark": "tationnis: TATIONNIS thing\nTATIONNIS.1: \"tationnis\" WS",
      "pddl": "(:action TATIONNIS\n    :parameters (?e - pineger_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (onesive ?e)\n        )\n    :effect (and\n        (pineger ?e)\n        (not (onesive ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not pineger-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not onesive.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now pineger.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To tationnis is to make something pineger_able and onesive be pineger.",
      "asp": "{ action_t(TURN,tationnis,THING):at_t(TURN,THING,ROOM),pineger_able(THING),onesive_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npineger_t(TURN+1,THING) :- action_t(TURN,tationnis,THING).\nonesive_t(TURN+1,THING) :- turn(TURN), onesive_t(TURN,THING), not action_t(TURN,tationnis,THING).",
      "type_name": "tationnis"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "gurlite",
      "exit_targets": [
        "redaka",
        "puranity"
      ],
      "max_connections": 1,
      "type_name": "gurlite"
    },
    {
      "repr_str": "puranity",
      "exit_targets": [
        "gurlite"
      ],
      "max_connections": 3,
      "type_name": "puranity"
    },
    {
      "repr_str": "redaka",
      "exit_targets": [
        "puranity",
        "caligaticed"
      ],
      "max_connections": 2,
      "type_name": "redaka"
    },
    {
      "repr_str": "caligaticed",
      "exit_targets": [
        "redaka",
        "puranity",
        "gurlite"
      ],
      "max_connections": 2,
      "type_name": "caligaticed"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "pienthor",
      "traits": [
        "exabarb_able"
      ],
      "standard_locations": [
        "puranity",
        "caligaticed"
      ],
      "type_name": "pienthor"
    },
    {
      "repr_str": "cophaal",
      "traits": [
        "exabarb_able"
      ],
      "standard_locations": [
        "gurlite"
      ],
      "type_name": "cophaal"
    },
    {
      "repr_str": "telyphy",
      "traits": [
        "vatmene_able",
        "exabarb_able"
      ],
      "standard_locations": [
        "caligaticed",
        "redaka"
      ],
      "type_name": "telyphy"
    },
    {
      "repr_str": "aribess",
      "traits": [
        "vatmene_able",
        "pineger_able"
      ],
      "standard_locations": [
        "caligaticed"
      ],
      "type_name": "aribess"
    },
    {
      "repr_str": "ubdonee",
      "traits": [
        "vatmene_able",
        "exabarb_able"
      ],
      "standard_locations": [
        "caligaticed",
        "puranity"
      ],
      "type_name": "ubdonee"
    },
    {
      "repr_str": "tecural",
      "traits": [
        "vatmene_able"
      ],
      "standard_locations": [
        "gurlite",
        "caligaticed"
      ],
      "type_name": "tecural"
    },
    {
      "repr_str": "pakably",
      "traits": [
        "vatmene_able"
      ],
      "standard_locations": [
        "caligaticed"
      ],
      "type_name": "pakably"
    },
    {
      "repr_str": "rogisart",
      "traits": [
        "pineger_able",
        "exabarb_able"
      ],
      "standard_locations": [
        "caligaticed"
      ],
      "type_name": "rogisart"
    },
    {
      "repr_str": "hocyard",
      "traits": [
        "exabarb_able",
        "vatmene_able"
      ],
      "standard_locations": [
        "puranity"
      ],
      "type_name": "hocyard"
    },
    {
      "repr_str": "ansubder",
      "traits": [
        "pineger_able"
      ],
      "standard_locations": [
        "gurlite",
        "redaka"
      ],
      "type_name": "ansubder"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "gurlite",
          "puranity",
          "redaka",
          "caligaticed"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "pienthor",
          "cophaal",
          "telyphy",
          "aribess",
          "ubdonee",
          "tecural",
          "pakably",
          "rogisart",
          "hocyard",
          "ansubder",
          "player",
          "inventory",
          "floor"
        ],
        "exabarb_able": [
          "pienthor",
          "cophaal",
          "telyphy",
          "ubdonee",
          "rogisart",
          "hocyard"
        ],
        "vatmene_able": [
          "telyphy",
          "aribess",
          "ubdonee",
          "tecural",
          "pakably",
          "hocyard"
        ],
        "pineger_able": [
          "aribess",
          "rogisart",
          "ansubder"
        ]
      },
      "predicates": [
        {
          "predicate_id": "exabarb",
          "variable": "e",
          "mutability": "exabarb_able"
        },
        {
          "predicate_id": "vatmene",
          "variable": "e",
          "mutability": "vatmene_able"
        },
        {
          "predicate_id": "ioblex",
          "variable": "e",
          "mutability": "vatmene_able"
        },
        {
          "predicate_id": "pineger",
          "variable": "e",
          "mutability": "pineger_able"
        },
        {
          "predicate_id": "earatory",
          "variable": "e",
          "mutability": "pineger_able"
        },
        {
          "predicate_id": "onesive",
          "variable": "e",
          "mutability": "pineger_able"
        }
      ]
    }
  ]
}