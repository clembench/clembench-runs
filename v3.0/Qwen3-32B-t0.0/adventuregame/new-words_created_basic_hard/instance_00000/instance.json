{
  "game_id": 0,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can mator, unbal, gatic, remic, ratic and proar.\n\nYour goal for this game is: Make the inat mateny, the diale unsust and the subst dented.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(decte1,unree1)",
    "at(enticed1,iness1)",
    "at(inat1,cally1)",
    "at(pante1,cally1)",
    "at(eness1,cally1)",
    "at(mical1,cally1)",
    "at(sness1,cally1)",
    "at(diale1,uness1)",
    "at(scont1,unree1)",
    "at(subst1,cally1)",
    "at(player1,cally1)",
    "type(player1,player)",
    "type(subst1,subst)",
    "type(scont1,scont)",
    "type(diale1,diale)",
    "type(sness1,sness)",
    "type(mical1,mical)",
    "type(eness1,eness)",
    "type(pante1,pante)",
    "type(inat1,inat)",
    "type(enticed1,enticed)",
    "type(decte1,decte)",
    "room(unree1,unree)",
    "room(iness1,iness)",
    "room(uness1,uness)",
    "room(cally1,cally)",
    "unsust(enticed1)",
    "unsust(pante1)",
    "unsust(eness1)",
    "unsust(mical1)",
    "exper(sness1)",
    "exper(diale1)",
    "mateny(decte1)",
    "stord(sness1)",
    "aphoned(inat1)",
    "exit(unree1,iness1)",
    "exit(iness1,unree1)",
    "exit(uness1,iness1)",
    "exit(cally1,unree1)",
    "exit(unree1,cally1)",
    "exit(iness1,uness1)",
    "dented_able(subst1)",
    "dented_able(scont1)",
    "dented_able(diale1)",
    "dented_able(mical1)",
    "dented_able(inat1)",
    "dented_able(enticed1)",
    "unsust_able(diale1)",
    "unsust_able(sness1)",
    "unsust_able(mical1)",
    "unsust_able(eness1)",
    "unsust_able(pante1)",
    "unsust_able(enticed1)",
    "mateny_able(sness1)",
    "mateny_able(inat1)",
    "mateny_able(decte1)"
  ],
  "goal_state": [
    "dented(subst1)",
    "unsust(diale1)",
    "mateny(inat1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "mator",
      "subst1"
    ],
    [
      "proar",
      "inat1"
    ],
    [
      "go",
      "unree1"
    ],
    [
      "go",
      "iness1"
    ],
    [
      "go",
      "uness1"
    ],
    [
      "gatic",
      "diale1"
    ]
  ],
  "optimal_commands": [
    "mator subst",
    "proar inat",
    "go unree",
    "go iness",
    "go uness",
    "gatic diale"
  ],
  "action_definitions": [
    {
      "lark": "mator: MATOR thing\nMATOR.1: \"mator\" WS",
      "pddl": "(:action MATOR\n    :parameters (?e - dented_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (dented ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not dented-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now dented.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To mator is to make something dented_able dented.",
      "asp": "{ action_t(TURN,mator,THING):at_t(TURN,THING,ROOM),dented_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndented_t(TURN+1,THING) :- action_t(TURN,mator,THING).\ndented_t(TURN+1,THING) :- turn(TURN), dented_t(TURN,THING).",
      "type_name": "mator"
    },
    {
      "lark": "unbal: UNBAL thing\nUNBAL.1: \"unbal\" WS",
      "pddl": "(:action UNBAL\n    :parameters (?e - unsust_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (unsust ?e)\n        )\n    :effect (and\n        (exper ?e)\n        (not (unsust ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not unsust-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not unsust.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now exper.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To unbal is to make something unsust_able and unsust be exper.",
      "asp": "{ action_t(TURN,unbal,THING):at_t(TURN,THING,ROOM),unsust_able(THING),unsust_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nexper_t(TURN+1,THING) :- action_t(TURN,unbal,THING).\nunsust_t(TURN+1,THING) :- turn(TURN), unsust_t(TURN,THING), not action_t(TURN,unbal,THING).",
      "type_name": "unbal"
    },
    {
      "lark": "gatic: GATIC thing\nGATIC.1: \"gatic\" WS",
      "pddl": "(:action GATIC\n    :parameters (?e - unsust_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (exper ?e)\n        )\n    :effect (and\n        (unsust ?e)\n        (not (exper ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not unsust-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not exper.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now unsust.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To gatic is to make something unsust_able and exper be unsust.",
      "asp": "{ action_t(TURN,gatic,THING):at_t(TURN,THING,ROOM),unsust_able(THING),exper_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nunsust_t(TURN+1,THING) :- action_t(TURN,gatic,THING).\nexper_t(TURN+1,THING) :- turn(TURN), exper_t(TURN,THING), not action_t(TURN,gatic,THING).",
      "type_name": "gatic"
    },
    {
      "lark": "ratic: RATIC thing\nRATIC.1: \"ratic\" WS",
      "pddl": "(:action RATIC\n    :parameters (?e - mateny_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (mateny ?e)\n        )\n    :effect (and\n        (stord ?e)\n        (not (mateny ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not mateny-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not mateny.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now stord.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ratic is to make something mateny_able and mateny be stord.",
      "asp": "{ action_t(TURN,ratic,THING):at_t(TURN,THING,ROOM),mateny_able(THING),mateny_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nstord_t(TURN+1,THING) :- action_t(TURN,ratic,THING).\nmateny_t(TURN+1,THING) :- turn(TURN), mateny_t(TURN,THING), not action_t(TURN,ratic,THING).",
      "type_name": "ratic"
    },
    {
      "lark": "remic: REMIC thing\nREMIC.1: \"remic\" WS",
      "pddl": "(:action REMIC\n    :parameters (?e - mateny_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (stord ?e)\n        )\n    :effect (and\n        (aphoned ?e)\n        (not (stord ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not mateny-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not stord.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now aphoned.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To remic is to make something mateny_able and stord be aphoned.",
      "asp": "{ action_t(TURN,remic,THING):at_t(TURN,THING,ROOM),mateny_able(THING),stord_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\naphoned_t(TURN+1,THING) :- action_t(TURN,remic,THING).\nstord_t(TURN+1,THING) :- turn(TURN), stord_t(TURN,THING), not action_t(TURN,remic,THING).",
      "type_name": "remic"
    },
    {
      "lark": "proar: PROAR thing\nPROAR.1: \"proar\" WS",
      "pddl": "(:action PROAR\n    :parameters (?e - mateny_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (aphoned ?e)\n        )\n    :effect (and\n        (mateny ?e)\n        (not (aphoned ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not mateny-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not aphoned.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now mateny.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To proar is to make something mateny_able and aphoned be mateny.",
      "asp": "{ action_t(TURN,proar,THING):at_t(TURN,THING,ROOM),mateny_able(THING),aphoned_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nmateny_t(TURN+1,THING) :- action_t(TURN,proar,THING).\naphoned_t(TURN+1,THING) :- turn(TURN), aphoned_t(TURN,THING), not action_t(TURN,proar,THING).",
      "type_name": "proar"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "unree",
      "exit_targets": [
        "uness",
        "iness"
      ],
      "max_connections": 1,
      "type_name": "unree"
    },
    {
      "repr_str": "iness",
      "exit_targets": [
        "unree"
      ],
      "max_connections": 3,
      "type_name": "iness"
    },
    {
      "repr_str": "uness",
      "exit_targets": [
        "iness",
        "cally"
      ],
      "max_connections": 2,
      "type_name": "uness"
    },
    {
      "repr_str": "cally",
      "exit_targets": [
        "uness",
        "iness",
        "unree"
      ],
      "max_connections": 2,
      "type_name": "cally"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "subst",
      "traits": [
        "dented_able"
      ],
      "standard_locations": [
        "iness",
        "cally"
      ],
      "type_name": "subst"
    },
    {
      "repr_str": "scont",
      "traits": [
        "dented_able"
      ],
      "standard_locations": [
        "unree"
      ],
      "type_name": "scont"
    },
    {
      "repr_str": "diale",
      "traits": [
        "unsust_able",
        "dented_able"
      ],
      "standard_locations": [
        "cally",
        "uness"
      ],
      "type_name": "diale"
    },
    {
      "repr_str": "sness",
      "traits": [
        "unsust_able",
        "mateny_able"
      ],
      "standard_locations": [
        "cally"
      ],
      "type_name": "sness"
    },
    {
      "repr_str": "mical",
      "traits": [
        "unsust_able",
        "dented_able"
      ],
      "standard_locations": [
        "cally",
        "iness"
      ],
      "type_name": "mical"
    },
    {
      "repr_str": "eness",
      "traits": [
        "unsust_able"
      ],
      "standard_locations": [
        "unree",
        "cally"
      ],
      "type_name": "eness"
    },
    {
      "repr_str": "pante",
      "traits": [
        "unsust_able"
      ],
      "standard_locations": [
        "cally"
      ],
      "type_name": "pante"
    },
    {
      "repr_str": "inat",
      "traits": [
        "mateny_able",
        "dented_able"
      ],
      "standard_locations": [
        "cally"
      ],
      "type_name": "inat"
    },
    {
      "repr_str": "enticed",
      "traits": [
        "dented_able",
        "unsust_able"
      ],
      "standard_locations": [
        "iness"
      ],
      "type_name": "enticed"
    },
    {
      "repr_str": "decte",
      "traits": [
        "mateny_able"
      ],
      "standard_locations": [
        "unree",
        "uness"
      ],
      "type_name": "decte"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "unree",
          "iness",
          "uness",
          "cally"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "subst",
          "scont",
          "diale",
          "sness",
          "mical",
          "eness",
          "pante",
          "inat",
          "enticed",
          "decte",
          "player",
          "inventory",
          "floor"
        ],
        "dented_able": [
          "subst",
          "scont",
          "diale",
          "mical",
          "inat",
          "enticed"
        ],
        "unsust_able": [
          "diale",
          "sness",
          "mical",
          "eness",
          "pante",
          "enticed"
        ],
        "mateny_able": [
          "sness",
          "inat",
          "decte"
        ]
      },
      "predicates": [
        {
          "predicate_id": "dented",
          "variable": "e",
          "mutability": "dented_able"
        },
        {
          "predicate_id": "unsust",
          "variable": "e",
          "mutability": "unsust_able"
        },
        {
          "predicate_id": "exper",
          "variable": "e",
          "mutability": "unsust_able"
        },
        {
          "predicate_id": "mateny",
          "variable": "e",
          "mutability": "mateny_able"
        },
        {
          "predicate_id": "stord",
          "variable": "e",
          "mutability": "mateny_able"
        },
        {
          "predicate_id": "aphoned",
          "variable": "e",
          "mutability": "mateny_able"
        }
      ]
    }
  ]
}