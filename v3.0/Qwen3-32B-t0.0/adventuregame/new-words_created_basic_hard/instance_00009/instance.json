{
  "game_id": 9,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can propress, atifory, alful, adcry, spidene and pnestay.\n\nYour goal for this game is: Make the oubiced ecastic, the prachon dedulag and the mindly ropile.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(eriant1,conader1)",
    "at(tationsh1,onable1)",
    "at(mindly1,sinark1)",
    "at(ionity1,sinark1)",
    "at(epteria1,sinark1)",
    "at(uncepist1,sinark1)",
    "at(clednee1,sinark1)",
    "at(oubiced1,aterve1)",
    "at(ickle1,conader1)",
    "at(prachon1,sinark1)",
    "at(player1,sinark1)",
    "type(player1,player)",
    "type(prachon1,prachon)",
    "type(ickle1,ickle)",
    "type(oubiced1,oubiced)",
    "type(clednee1,clednee)",
    "type(uncepist1,uncepist)",
    "type(epteria1,epteria)",
    "type(ionity1,ionity)",
    "type(mindly1,mindly)",
    "type(tationsh1,tationsh)",
    "type(eriant1,eriant)",
    "room(conader1,conader)",
    "room(onable1,onable)",
    "room(aterve1,aterve)",
    "room(sinark1,sinark)",
    "ecastic(tationsh1)",
    "ecastic(ionity1)",
    "ecastic(epteria1)",
    "ecastic(uncepist1)",
    "phothipy(clednee1)",
    "phothipy(oubiced1)",
    "ropile(eriant1)",
    "fuster(clednee1)",
    "rancal(mindly1)",
    "exit(conader1,onable1)",
    "exit(onable1,conader1)",
    "exit(aterve1,onable1)",
    "exit(sinark1,conader1)",
    "exit(conader1,sinark1)",
    "exit(onable1,aterve1)",
    "dedulag_able(prachon1)",
    "dedulag_able(ickle1)",
    "dedulag_able(oubiced1)",
    "dedulag_able(uncepist1)",
    "dedulag_able(mindly1)",
    "dedulag_able(tationsh1)",
    "ecastic_able(oubiced1)",
    "ecastic_able(clednee1)",
    "ecastic_able(uncepist1)",
    "ecastic_able(epteria1)",
    "ecastic_able(ionity1)",
    "ecastic_able(tationsh1)",
    "ropile_able(clednee1)",
    "ropile_able(mindly1)",
    "ropile_able(eriant1)"
  ],
  "goal_state": [
    "dedulag(prachon1)",
    "ecastic(oubiced1)",
    "ropile(mindly1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "spidene",
      "prachon1"
    ],
    [
      "pnestay",
      "mindly1"
    ],
    [
      "go",
      "conader1"
    ],
    [
      "go",
      "onable1"
    ],
    [
      "go",
      "aterve1"
    ],
    [
      "atifory",
      "oubiced1"
    ]
  ],
  "optimal_commands": [
    "spidene prachon",
    "pnestay mindly",
    "go conader",
    "go onable",
    "go aterve",
    "atifory oubiced"
  ],
  "action_definitions": [
    {
      "lark": "spidene: SPIDENE thing\nSPIDENE.1: \"spidene\" WS",
      "pddl": "(:action SPIDENE\n    :parameters (?e - dedulag_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (dedulag ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not dedulag-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now dedulag.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To spidene is to make something dedulag_able dedulag.",
      "asp": "{ action_t(TURN,spidene,THING):at_t(TURN,THING,ROOM),dedulag_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndedulag_t(TURN+1,THING) :- action_t(TURN,spidene,THING).\ndedulag_t(TURN+1,THING) :- turn(TURN), dedulag_t(TURN,THING).",
      "type_name": "spidene"
    },
    {
      "lark": "adcry: ADCRY thing\nADCRY.1: \"adcry\" WS",
      "pddl": "(:action ADCRY\n    :parameters (?e - ecastic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ecastic ?e)\n        )\n    :effect (and\n        (phothipy ?e)\n        (not (ecastic ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ecastic-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not ecastic.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now phothipy.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To adcry is to make something ecastic_able and ecastic be phothipy.",
      "asp": "{ action_t(TURN,adcry,THING):at_t(TURN,THING,ROOM),ecastic_able(THING),ecastic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nphothipy_t(TURN+1,THING) :- action_t(TURN,adcry,THING).\necastic_t(TURN+1,THING) :- turn(TURN), ecastic_t(TURN,THING), not action_t(TURN,adcry,THING).",
      "type_name": "adcry"
    },
    {
      "lark": "atifory: ATIFORY thing\nATIFORY.1: \"atifory\" WS",
      "pddl": "(:action ATIFORY\n    :parameters (?e - ecastic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (phothipy ?e)\n        )\n    :effect (and\n        (ecastic ?e)\n        (not (phothipy ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ecastic-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not phothipy.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ecastic.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To atifory is to make something ecastic_able and phothipy be ecastic.",
      "asp": "{ action_t(TURN,atifory,THING):at_t(TURN,THING,ROOM),ecastic_able(THING),phothipy_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\necastic_t(TURN+1,THING) :- action_t(TURN,atifory,THING).\nphothipy_t(TURN+1,THING) :- turn(TURN), phothipy_t(TURN,THING), not action_t(TURN,atifory,THING).",
      "type_name": "atifory"
    },
    {
      "lark": "alful: ALFUL thing\nALFUL.1: \"alful\" WS",
      "pddl": "(:action ALFUL\n    :parameters (?e - ropile_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ropile ?e)\n        )\n    :effect (and\n        (fuster ?e)\n        (not (ropile ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ropile-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not ropile.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now fuster.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To alful is to make something ropile_able and ropile be fuster.",
      "asp": "{ action_t(TURN,alful,THING):at_t(TURN,THING,ROOM),ropile_able(THING),ropile_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nfuster_t(TURN+1,THING) :- action_t(TURN,alful,THING).\nropile_t(TURN+1,THING) :- turn(TURN), ropile_t(TURN,THING), not action_t(TURN,alful,THING).",
      "type_name": "alful"
    },
    {
      "lark": "propress: PROPRESS thing\nPROPRESS.1: \"propress\" WS",
      "pddl": "(:action PROPRESS\n    :parameters (?e - ropile_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (fuster ?e)\n        )\n    :effect (and\n        (rancal ?e)\n        (not (fuster ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ropile-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not fuster.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now rancal.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To propress is to make something ropile_able and fuster be rancal.",
      "asp": "{ action_t(TURN,propress,THING):at_t(TURN,THING,ROOM),ropile_able(THING),fuster_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nrancal_t(TURN+1,THING) :- action_t(TURN,propress,THING).\nfuster_t(TURN+1,THING) :- turn(TURN), fuster_t(TURN,THING), not action_t(TURN,propress,THING).",
      "type_name": "propress"
    },
    {
      "lark": "pnestay: PNESTAY thing\nPNESTAY.1: \"pnestay\" WS",
      "pddl": "(:action PNESTAY\n    :parameters (?e - ropile_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (rancal ?e)\n        )\n    :effect (and\n        (ropile ?e)\n        (not (rancal ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ropile-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not rancal.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ropile.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To pnestay is to make something ropile_able and rancal be ropile.",
      "asp": "{ action_t(TURN,pnestay,THING):at_t(TURN,THING,ROOM),ropile_able(THING),rancal_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nropile_t(TURN+1,THING) :- action_t(TURN,pnestay,THING).\nrancal_t(TURN+1,THING) :- turn(TURN), rancal_t(TURN,THING), not action_t(TURN,pnestay,THING).",
      "type_name": "pnestay"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "conader",
      "exit_targets": [
        "aterve",
        "onable"
      ],
      "max_connections": 1,
      "type_name": "conader"
    },
    {
      "repr_str": "onable",
      "exit_targets": [
        "conader"
      ],
      "max_connections": 3,
      "type_name": "onable"
    },
    {
      "repr_str": "aterve",
      "exit_targets": [
        "onable",
        "sinark"
      ],
      "max_connections": 2,
      "type_name": "aterve"
    },
    {
      "repr_str": "sinark",
      "exit_targets": [
        "aterve",
        "onable",
        "conader"
      ],
      "max_connections": 2,
      "type_name": "sinark"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "prachon",
      "traits": [
        "dedulag_able"
      ],
      "standard_locations": [
        "onable",
        "sinark"
      ],
      "type_name": "prachon"
    },
    {
      "repr_str": "ickle",
      "traits": [
        "dedulag_able"
      ],
      "standard_locations": [
        "conader"
      ],
      "type_name": "ickle"
    },
    {
      "repr_str": "oubiced",
      "traits": [
        "ecastic_able",
        "dedulag_able"
      ],
      "standard_locations": [
        "sinark",
        "aterve"
      ],
      "type_name": "oubiced"
    },
    {
      "repr_str": "clednee",
      "traits": [
        "ecastic_able",
        "ropile_able"
      ],
      "standard_locations": [
        "sinark"
      ],
      "type_name": "clednee"
    },
    {
      "repr_str": "uncepist",
      "traits": [
        "ecastic_able",
        "dedulag_able"
      ],
      "standard_locations": [
        "sinark",
        "onable"
      ],
      "type_name": "uncepist"
    },
    {
      "repr_str": "epteria",
      "traits": [
        "ecastic_able"
      ],
      "standard_locations": [
        "conader",
        "sinark"
      ],
      "type_name": "epteria"
    },
    {
      "repr_str": "ionity",
      "traits": [
        "ecastic_able"
      ],
      "standard_locations": [
        "sinark"
      ],
      "type_name": "ionity"
    },
    {
      "repr_str": "mindly",
      "traits": [
        "ropile_able",
        "dedulag_able"
      ],
      "standard_locations": [
        "sinark"
      ],
      "type_name": "mindly"
    },
    {
      "repr_str": "tationsh",
      "traits": [
        "dedulag_able",
        "ecastic_able"
      ],
      "standard_locations": [
        "onable"
      ],
      "type_name": "tationsh"
    },
    {
      "repr_str": "eriant",
      "traits": [
        "ropile_able"
      ],
      "standard_locations": [
        "conader",
        "aterve"
      ],
      "type_name": "eriant"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "conader",
          "onable",
          "aterve",
          "sinark"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "prachon",
          "ickle",
          "oubiced",
          "clednee",
          "uncepist",
          "epteria",
          "ionity",
          "mindly",
          "tationsh",
          "eriant",
          "player",
          "inventory",
          "floor"
        ],
        "dedulag_able": [
          "prachon",
          "ickle",
          "oubiced",
          "uncepist",
          "mindly",
          "tationsh"
        ],
        "ecastic_able": [
          "oubiced",
          "clednee",
          "uncepist",
          "epteria",
          "ionity",
          "tationsh"
        ],
        "ropile_able": [
          "clednee",
          "mindly",
          "eriant"
        ]
      },
      "predicates": [
        {
          "predicate_id": "dedulag",
          "variable": "e",
          "mutability": "dedulag_able"
        },
        {
          "predicate_id": "ecastic",
          "variable": "e",
          "mutability": "ecastic_able"
        },
        {
          "predicate_id": "phothipy",
          "variable": "e",
          "mutability": "ecastic_able"
        },
        {
          "predicate_id": "ropile",
          "variable": "e",
          "mutability": "ropile_able"
        },
        {
          "predicate_id": "fuster",
          "variable": "e",
          "mutability": "ropile_able"
        },
        {
          "predicate_id": "rancal",
          "variable": "e",
          "mutability": "ropile_able"
        }
      ]
    }
  ]
}