{
  "game_id": 7,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can onser, mellum, clogery, ellous, ially and upbes.\n\nYour goal for this game is: Make the hetle anird, the ioness opige and the rotont reforian.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(venism1,routiced1)",
    "at(toxist1,guaced1)",
    "at(rotont1,atival1)",
    "at(herper1,atival1)",
    "at(equadish1,atival1)",
    "at(fervan1,atival1)",
    "at(thium1,atival1)",
    "at(hetle1,emingly1)",
    "at(attle1,routiced1)",
    "at(ioness1,atival1)",
    "at(player1,atival1)",
    "type(player1,player)",
    "type(ioness1,ioness)",
    "type(attle1,attle)",
    "type(hetle1,hetle)",
    "type(thium1,thium)",
    "type(fervan1,fervan)",
    "type(equadish1,equadish)",
    "type(herper1,herper)",
    "type(rotont1,rotont)",
    "type(toxist1,toxist)",
    "type(venism1,venism)",
    "room(routiced1,routiced)",
    "room(guaced1,guaced)",
    "room(emingly1,emingly)",
    "room(atival1,atival)",
    "anird(toxist1)",
    "anird(herper1)",
    "anird(equadish1)",
    "anird(fervan1)",
    "everce(thium1)",
    "everce(hetle1)",
    "reforian(venism1)",
    "cunad(thium1)",
    "cioty(rotont1)",
    "exit(routiced1,guaced1)",
    "exit(guaced1,routiced1)",
    "exit(emingly1,guaced1)",
    "exit(atival1,routiced1)",
    "exit(routiced1,atival1)",
    "exit(guaced1,emingly1)",
    "opige_able(ioness1)",
    "opige_able(attle1)",
    "opige_able(hetle1)",
    "opige_able(fervan1)",
    "opige_able(rotont1)",
    "opige_able(toxist1)",
    "anird_able(hetle1)",
    "anird_able(thium1)",
    "anird_able(fervan1)",
    "anird_able(equadish1)",
    "anird_able(herper1)",
    "anird_able(toxist1)",
    "reforian_able(thium1)",
    "reforian_able(rotont1)",
    "reforian_able(venism1)"
  ],
  "goal_state": [
    "opige(ioness1)",
    "anird(hetle1)",
    "reforian(rotont1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "mellum",
      "ioness1"
    ],
    [
      "clogery",
      "rotont1"
    ],
    [
      "go",
      "routiced1"
    ],
    [
      "go",
      "guaced1"
    ],
    [
      "go",
      "emingly1"
    ],
    [
      "ially",
      "hetle1"
    ]
  ],
  "optimal_commands": [
    "mellum ioness",
    "clogery rotont",
    "go routiced",
    "go guaced",
    "go emingly",
    "ially hetle"
  ],
  "action_definitions": [
    {
      "lark": "mellum: MELLUM thing\nMELLUM.1: \"mellum\" WS",
      "pddl": "(:action MELLUM\n    :parameters (?e - opige_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (opige ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not opige-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now opige.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To mellum is to make something opige_able opige.",
      "asp": "{ action_t(TURN,mellum,THING):at_t(TURN,THING,ROOM),opige_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nopige_t(TURN+1,THING) :- action_t(TURN,mellum,THING).\nopige_t(TURN+1,THING) :- turn(TURN), opige_t(TURN,THING).",
      "type_name": "mellum"
    },
    {
      "lark": "upbes: UPBES thing\nUPBES.1: \"upbes\" WS",
      "pddl": "(:action UPBES\n    :parameters (?e - anird_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (anird ?e)\n        )\n    :effect (and\n        (everce ?e)\n        (not (anird ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not anird-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not anird.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now everce.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To upbes is to make something anird_able and anird be everce.",
      "asp": "{ action_t(TURN,upbes,THING):at_t(TURN,THING,ROOM),anird_able(THING),anird_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\neverce_t(TURN+1,THING) :- action_t(TURN,upbes,THING).\nanird_t(TURN+1,THING) :- turn(TURN), anird_t(TURN,THING), not action_t(TURN,upbes,THING).",
      "type_name": "upbes"
    },
    {
      "lark": "ially: IALLY thing\nIALLY.1: \"ially\" WS",
      "pddl": "(:action IALLY\n    :parameters (?e - anird_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (everce ?e)\n        )\n    :effect (and\n        (anird ?e)\n        (not (everce ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not anird-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not everce.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now anird.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ially is to make something anird_able and everce be anird.",
      "asp": "{ action_t(TURN,ially,THING):at_t(TURN,THING,ROOM),anird_able(THING),everce_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nanird_t(TURN+1,THING) :- action_t(TURN,ially,THING).\neverce_t(TURN+1,THING) :- turn(TURN), everce_t(TURN,THING), not action_t(TURN,ially,THING).",
      "type_name": "ially"
    },
    {
      "lark": "onser: ONSER thing\nONSER.1: \"onser\" WS",
      "pddl": "(:action ONSER\n    :parameters (?e - reforian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (reforian ?e)\n        )\n    :effect (and\n        (cunad ?e)\n        (not (reforian ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not reforian-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not reforian.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now cunad.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To onser is to make something reforian_able and reforian be cunad.",
      "asp": "{ action_t(TURN,onser,THING):at_t(TURN,THING,ROOM),reforian_able(THING),reforian_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ncunad_t(TURN+1,THING) :- action_t(TURN,onser,THING).\nreforian_t(TURN+1,THING) :- turn(TURN), reforian_t(TURN,THING), not action_t(TURN,onser,THING).",
      "type_name": "onser"
    },
    {
      "lark": "ellous: ELLOUS thing\nELLOUS.1: \"ellous\" WS",
      "pddl": "(:action ELLOUS\n    :parameters (?e - reforian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (cunad ?e)\n        )\n    :effect (and\n        (cioty ?e)\n        (not (cunad ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not reforian-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not cunad.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now cioty.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ellous is to make something reforian_able and cunad be cioty.",
      "asp": "{ action_t(TURN,ellous,THING):at_t(TURN,THING,ROOM),reforian_able(THING),cunad_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ncioty_t(TURN+1,THING) :- action_t(TURN,ellous,THING).\ncunad_t(TURN+1,THING) :- turn(TURN), cunad_t(TURN,THING), not action_t(TURN,ellous,THING).",
      "type_name": "ellous"
    },
    {
      "lark": "clogery: CLOGERY thing\nCLOGERY.1: \"clogery\" WS",
      "pddl": "(:action CLOGERY\n    :parameters (?e - reforian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (cioty ?e)\n        )\n    :effect (and\n        (reforian ?e)\n        (not (cioty ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not reforian-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not cioty.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now reforian.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To clogery is to make something reforian_able and cioty be reforian.",
      "asp": "{ action_t(TURN,clogery,THING):at_t(TURN,THING,ROOM),reforian_able(THING),cioty_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nreforian_t(TURN+1,THING) :- action_t(TURN,clogery,THING).\ncioty_t(TURN+1,THING) :- turn(TURN), cioty_t(TURN,THING), not action_t(TURN,clogery,THING).",
      "type_name": "clogery"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "routiced",
      "exit_targets": [
        "emingly",
        "guaced"
      ],
      "max_connections": 1,
      "type_name": "routiced"
    },
    {
      "repr_str": "guaced",
      "exit_targets": [
        "routiced"
      ],
      "max_connections": 3,
      "type_name": "guaced"
    },
    {
      "repr_str": "emingly",
      "exit_targets": [
        "guaced",
        "atival"
      ],
      "max_connections": 2,
      "type_name": "emingly"
    },
    {
      "repr_str": "atival",
      "exit_targets": [
        "emingly",
        "guaced",
        "routiced"
      ],
      "max_connections": 2,
      "type_name": "atival"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "ioness",
      "traits": [
        "opige_able"
      ],
      "standard_locations": [
        "guaced",
        "atival"
      ],
      "type_name": "ioness"
    },
    {
      "repr_str": "attle",
      "traits": [
        "opige_able"
      ],
      "standard_locations": [
        "routiced"
      ],
      "type_name": "attle"
    },
    {
      "repr_str": "hetle",
      "traits": [
        "anird_able",
        "opige_able"
      ],
      "standard_locations": [
        "atival",
        "emingly"
      ],
      "type_name": "hetle"
    },
    {
      "repr_str": "thium",
      "traits": [
        "anird_able",
        "reforian_able"
      ],
      "standard_locations": [
        "atival"
      ],
      "type_name": "thium"
    },
    {
      "repr_str": "fervan",
      "traits": [
        "anird_able",
        "opige_able"
      ],
      "standard_locations": [
        "atival",
        "guaced"
      ],
      "type_name": "fervan"
    },
    {
      "repr_str": "equadish",
      "traits": [
        "anird_able"
      ],
      "standard_locations": [
        "routiced",
        "atival"
      ],
      "type_name": "equadish"
    },
    {
      "repr_str": "herper",
      "traits": [
        "anird_able"
      ],
      "standard_locations": [
        "atival"
      ],
      "type_name": "herper"
    },
    {
      "repr_str": "rotont",
      "traits": [
        "reforian_able",
        "opige_able"
      ],
      "standard_locations": [
        "atival"
      ],
      "type_name": "rotont"
    },
    {
      "repr_str": "toxist",
      "traits": [
        "opige_able",
        "anird_able"
      ],
      "standard_locations": [
        "guaced"
      ],
      "type_name": "toxist"
    },
    {
      "repr_str": "venism",
      "traits": [
        "reforian_able"
      ],
      "standard_locations": [
        "routiced",
        "emingly"
      ],
      "type_name": "venism"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "routiced",
          "guaced",
          "emingly",
          "atival"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "ioness",
          "attle",
          "hetle",
          "thium",
          "fervan",
          "equadish",
          "herper",
          "rotont",
          "toxist",
          "venism",
          "player",
          "inventory",
          "floor"
        ],
        "opige_able": [
          "ioness",
          "attle",
          "hetle",
          "fervan",
          "rotont",
          "toxist"
        ],
        "anird_able": [
          "hetle",
          "thium",
          "fervan",
          "equadish",
          "herper",
          "toxist"
        ],
        "reforian_able": [
          "thium",
          "rotont",
          "venism"
        ]
      },
      "predicates": [
        {
          "predicate_id": "opige",
          "variable": "e",
          "mutability": "opige_able"
        },
        {
          "predicate_id": "anird",
          "variable": "e",
          "mutability": "anird_able"
        },
        {
          "predicate_id": "everce",
          "variable": "e",
          "mutability": "anird_able"
        },
        {
          "predicate_id": "reforian",
          "variable": "e",
          "mutability": "reforian_able"
        },
        {
          "predicate_id": "cunad",
          "variable": "e",
          "mutability": "reforian_able"
        },
        {
          "predicate_id": "cioty",
          "variable": "e",
          "mutability": "reforian_able"
        }
      ]
    }
  ]
}