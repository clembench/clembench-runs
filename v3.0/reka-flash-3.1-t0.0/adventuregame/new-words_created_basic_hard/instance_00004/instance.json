{
  "game_id": 4,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can iscad, eriat, ovesis, mingne, setral and lepht.\n\nYour goal for this game is: Make the strood aphistic, the aciong dolam and the swaiced ailly.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(ostion1,stful1)",
    "at(pyelly1,emoust1)",
    "at(strood1,encal1)",
    "at(eucty1,encal1)",
    "at(inchan1,encal1)",
    "at(oming1,encal1)",
    "at(perent1,encal1)",
    "at(swaiced1,etiont1)",
    "at(oroust1,stful1)",
    "at(aciong1,encal1)",
    "at(player1,encal1)",
    "type(player1,player)",
    "type(aciong1,aciong)",
    "type(oroust1,oroust)",
    "type(swaiced1,swaiced)",
    "type(perent1,perent)",
    "type(oming1,oming)",
    "type(inchan1,inchan)",
    "type(eucty1,eucty)",
    "type(strood1,strood)",
    "type(pyelly1,pyelly)",
    "type(ostion1,ostion)",
    "room(stful1,stful)",
    "room(emoust1,emoust)",
    "room(etiont1,etiont)",
    "room(encal1,encal)",
    "ailly(pyelly1)",
    "ailly(eucty1)",
    "ailly(inchan1)",
    "ailly(oming1)",
    "retart(perent1)",
    "retart(swaiced1)",
    "aphistic(ostion1)",
    "olict(perent1)",
    "eriated(strood1)",
    "exit(stful1,emoust1)",
    "exit(emoust1,stful1)",
    "exit(etiont1,emoust1)",
    "exit(encal1,stful1)",
    "exit(stful1,encal1)",
    "exit(emoust1,etiont1)",
    "dolam_able(aciong1)",
    "dolam_able(oroust1)",
    "dolam_able(swaiced1)",
    "dolam_able(oming1)",
    "dolam_able(strood1)",
    "dolam_able(pyelly1)",
    "ailly_able(swaiced1)",
    "ailly_able(perent1)",
    "ailly_able(oming1)",
    "ailly_able(inchan1)",
    "ailly_able(eucty1)",
    "ailly_able(pyelly1)",
    "aphistic_able(perent1)",
    "aphistic_able(strood1)",
    "aphistic_able(ostion1)"
  ],
  "goal_state": [
    "dolam(aciong1)",
    "ailly(swaiced1)",
    "aphistic(strood1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "eriat",
      "aciong1"
    ],
    [
      "setral",
      "strood1"
    ],
    [
      "go",
      "stful1"
    ],
    [
      "go",
      "emoust1"
    ],
    [
      "go",
      "etiont1"
    ],
    [
      "mingne",
      "swaiced1"
    ]
  ],
  "optimal_commands": [
    "eriat aciong",
    "setral strood",
    "go stful",
    "go emoust",
    "go etiont",
    "mingne swaiced"
  ],
  "action_definitions": [
    {
      "lark": "eriat: ERIAT thing\nERIAT.1: \"eriat\" WS",
      "pddl": "(:action ERIAT\n    :parameters (?e - dolam_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (dolam ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not dolam-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now dolam.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To eriat is to make something dolam_able dolam.",
      "asp": "{ action_t(TURN,eriat,THING):at_t(TURN,THING,ROOM),dolam_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndolam_t(TURN+1,THING) :- action_t(TURN,eriat,THING).\ndolam_t(TURN+1,THING) :- turn(TURN), dolam_t(TURN,THING).",
      "type_name": "eriat"
    },
    {
      "lark": "ovesis: OVESIS thing\nOVESIS.1: \"ovesis\" WS",
      "pddl": "(:action OVESIS\n    :parameters (?e - ailly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ailly ?e)\n        )\n    :effect (and\n        (retart ?e)\n        (not (ailly ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ailly-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not ailly.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now retart.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ovesis is to make something ailly_able and ailly be retart.",
      "asp": "{ action_t(TURN,ovesis,THING):at_t(TURN,THING,ROOM),ailly_able(THING),ailly_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nretart_t(TURN+1,THING) :- action_t(TURN,ovesis,THING).\nailly_t(TURN+1,THING) :- turn(TURN), ailly_t(TURN,THING), not action_t(TURN,ovesis,THING).",
      "type_name": "ovesis"
    },
    {
      "lark": "mingne: MINGNE thing\nMINGNE.1: \"mingne\" WS",
      "pddl": "(:action MINGNE\n    :parameters (?e - ailly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (retart ?e)\n        )\n    :effect (and\n        (ailly ?e)\n        (not (retart ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ailly-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not retart.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ailly.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To mingne is to make something ailly_able and retart be ailly.",
      "asp": "{ action_t(TURN,mingne,THING):at_t(TURN,THING,ROOM),ailly_able(THING),retart_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nailly_t(TURN+1,THING) :- action_t(TURN,mingne,THING).\nretart_t(TURN+1,THING) :- turn(TURN), retart_t(TURN,THING), not action_t(TURN,mingne,THING).",
      "type_name": "mingne"
    },
    {
      "lark": "lepht: LEPHT thing\nLEPHT.1: \"lepht\" WS",
      "pddl": "(:action LEPHT\n    :parameters (?e - aphistic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (aphistic ?e)\n        )\n    :effect (and\n        (olict ?e)\n        (not (aphistic ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not aphistic-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not aphistic.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now olict.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To lepht is to make something aphistic_able and aphistic be olict.",
      "asp": "{ action_t(TURN,lepht,THING):at_t(TURN,THING,ROOM),aphistic_able(THING),aphistic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nolict_t(TURN+1,THING) :- action_t(TURN,lepht,THING).\naphistic_t(TURN+1,THING) :- turn(TURN), aphistic_t(TURN,THING), not action_t(TURN,lepht,THING).",
      "type_name": "lepht"
    },
    {
      "lark": "iscad: ISCAD thing\nISCAD.1: \"iscad\" WS",
      "pddl": "(:action ISCAD\n    :parameters (?e - aphistic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (olict ?e)\n        )\n    :effect (and\n        (eriated ?e)\n        (not (olict ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not aphistic-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not olict.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now eriated.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To iscad is to make something aphistic_able and olict be eriated.",
      "asp": "{ action_t(TURN,iscad,THING):at_t(TURN,THING,ROOM),aphistic_able(THING),olict_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\neriated_t(TURN+1,THING) :- action_t(TURN,iscad,THING).\nolict_t(TURN+1,THING) :- turn(TURN), olict_t(TURN,THING), not action_t(TURN,iscad,THING).",
      "type_name": "iscad"
    },
    {
      "lark": "setral: SETRAL thing\nSETRAL.1: \"setral\" WS",
      "pddl": "(:action SETRAL\n    :parameters (?e - aphistic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (eriated ?e)\n        )\n    :effect (and\n        (aphistic ?e)\n        (not (eriated ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not aphistic-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not eriated.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now aphistic.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To setral is to make something aphistic_able and eriated be aphistic.",
      "asp": "{ action_t(TURN,setral,THING):at_t(TURN,THING,ROOM),aphistic_able(THING),eriated_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\naphistic_t(TURN+1,THING) :- action_t(TURN,setral,THING).\neriated_t(TURN+1,THING) :- turn(TURN), eriated_t(TURN,THING), not action_t(TURN,setral,THING).",
      "type_name": "setral"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "stful",
      "exit_targets": [
        "etiont",
        "emoust"
      ],
      "max_connections": 1,
      "type_name": "stful"
    },
    {
      "repr_str": "emoust",
      "exit_targets": [
        "stful"
      ],
      "max_connections": 3,
      "type_name": "emoust"
    },
    {
      "repr_str": "etiont",
      "exit_targets": [
        "emoust",
        "encal"
      ],
      "max_connections": 2,
      "type_name": "etiont"
    },
    {
      "repr_str": "encal",
      "exit_targets": [
        "etiont",
        "emoust",
        "stful"
      ],
      "max_connections": 2,
      "type_name": "encal"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "aciong",
      "traits": [
        "dolam_able"
      ],
      "standard_locations": [
        "emoust",
        "encal"
      ],
      "type_name": "aciong"
    },
    {
      "repr_str": "oroust",
      "traits": [
        "dolam_able"
      ],
      "standard_locations": [
        "stful"
      ],
      "type_name": "oroust"
    },
    {
      "repr_str": "swaiced",
      "traits": [
        "ailly_able",
        "dolam_able"
      ],
      "standard_locations": [
        "encal",
        "etiont"
      ],
      "type_name": "swaiced"
    },
    {
      "repr_str": "perent",
      "traits": [
        "ailly_able",
        "aphistic_able"
      ],
      "standard_locations": [
        "encal"
      ],
      "type_name": "perent"
    },
    {
      "repr_str": "oming",
      "traits": [
        "ailly_able",
        "dolam_able"
      ],
      "standard_locations": [
        "encal",
        "emoust"
      ],
      "type_name": "oming"
    },
    {
      "repr_str": "inchan",
      "traits": [
        "ailly_able"
      ],
      "standard_locations": [
        "stful",
        "encal"
      ],
      "type_name": "inchan"
    },
    {
      "repr_str": "eucty",
      "traits": [
        "ailly_able"
      ],
      "standard_locations": [
        "encal"
      ],
      "type_name": "eucty"
    },
    {
      "repr_str": "strood",
      "traits": [
        "aphistic_able",
        "dolam_able"
      ],
      "standard_locations": [
        "encal"
      ],
      "type_name": "strood"
    },
    {
      "repr_str": "pyelly",
      "traits": [
        "dolam_able",
        "ailly_able"
      ],
      "standard_locations": [
        "emoust"
      ],
      "type_name": "pyelly"
    },
    {
      "repr_str": "ostion",
      "traits": [
        "aphistic_able"
      ],
      "standard_locations": [
        "stful",
        "etiont"
      ],
      "type_name": "ostion"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "stful",
          "emoust",
          "etiont",
          "encal"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "aciong",
          "oroust",
          "swaiced",
          "perent",
          "oming",
          "inchan",
          "eucty",
          "strood",
          "pyelly",
          "ostion",
          "player",
          "inventory",
          "floor"
        ],
        "dolam_able": [
          "aciong",
          "oroust",
          "swaiced",
          "oming",
          "strood",
          "pyelly"
        ],
        "ailly_able": [
          "swaiced",
          "perent",
          "oming",
          "inchan",
          "eucty",
          "pyelly"
        ],
        "aphistic_able": [
          "perent",
          "strood",
          "ostion"
        ]
      },
      "predicates": [
        {
          "predicate_id": "dolam",
          "variable": "e",
          "mutability": "dolam_able"
        },
        {
          "predicate_id": "ailly",
          "variable": "e",
          "mutability": "ailly_able"
        },
        {
          "predicate_id": "retart",
          "variable": "e",
          "mutability": "ailly_able"
        },
        {
          "predicate_id": "aphistic",
          "variable": "e",
          "mutability": "aphistic_able"
        },
        {
          "predicate_id": "olict",
          "variable": "e",
          "mutability": "aphistic_able"
        },
        {
          "predicate_id": "eriated",
          "variable": "e",
          "mutability": "aphistic_able"
        }
      ]
    }
  ]
}