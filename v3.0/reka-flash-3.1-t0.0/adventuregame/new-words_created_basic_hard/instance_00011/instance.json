{
  "game_id": 11,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can amyoid, jolene, tritioush, oryter, atheris and urseum.\n\nYour goal for this game is: Make the utist hetioner, the icess tubilly and the anonaticed ippet.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(obilard1,oidemat1)",
    "at(robve1,chlove1)",
    "at(icess1,endroust1)",
    "at(lableve1,endroust1)",
    "at(stoaced1,endroust1)",
    "at(atedist1,endroust1)",
    "at(coepticed1,endroust1)",
    "at(anonaticed1,menzinee1)",
    "at(linkly1,oidemat1)",
    "at(utist1,endroust1)",
    "at(player1,endroust1)",
    "type(player1,player)",
    "type(utist1,utist)",
    "type(linkly1,linkly)",
    "type(anonaticed1,anonaticed)",
    "type(coepticed1,coepticed)",
    "type(atedist1,atedist)",
    "type(stoaced1,stoaced)",
    "type(lableve1,lableve)",
    "type(icess1,icess)",
    "type(robve1,robve)",
    "type(obilard1,obilard)",
    "room(oidemat1,oidemat)",
    "room(chlove1,chlove)",
    "room(menzinee1,menzinee)",
    "room(endroust1,endroust)",
    "ippet(robve1)",
    "ippet(lableve1)",
    "ippet(stoaced1)",
    "ippet(atedist1)",
    "hoxopal(coepticed1)",
    "hoxopal(anonaticed1)",
    "tubilly(obilard1)",
    "phorpiced(coepticed1)",
    "alidow(icess1)",
    "exit(oidemat1,chlove1)",
    "exit(chlove1,oidemat1)",
    "exit(menzinee1,chlove1)",
    "exit(endroust1,oidemat1)",
    "exit(oidemat1,endroust1)",
    "exit(chlove1,menzinee1)",
    "hetioner_able(utist1)",
    "hetioner_able(linkly1)",
    "hetioner_able(anonaticed1)",
    "hetioner_able(atedist1)",
    "hetioner_able(icess1)",
    "hetioner_able(robve1)",
    "ippet_able(anonaticed1)",
    "ippet_able(coepticed1)",
    "ippet_able(atedist1)",
    "ippet_able(stoaced1)",
    "ippet_able(lableve1)",
    "ippet_able(robve1)",
    "tubilly_able(coepticed1)",
    "tubilly_able(icess1)",
    "tubilly_able(obilard1)"
  ],
  "goal_state": [
    "hetioner(utist1)",
    "ippet(anonaticed1)",
    "tubilly(icess1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "oryter",
      "utist1"
    ],
    [
      "urseum",
      "icess1"
    ],
    [
      "go",
      "oidemat1"
    ],
    [
      "go",
      "chlove1"
    ],
    [
      "go",
      "menzinee1"
    ],
    [
      "tritioush",
      "anonaticed1"
    ]
  ],
  "optimal_commands": [
    "oryter utist",
    "urseum icess",
    "go oidemat",
    "go chlove",
    "go menzinee",
    "tritioush anonaticed"
  ],
  "action_definitions": [
    {
      "lark": "oryter: ORYTER thing\nORYTER.1: \"oryter\" WS",
      "pddl": "(:action ORYTER\n    :parameters (?e - hetioner_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (hetioner ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not hetioner-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now hetioner.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To oryter is to make something hetioner_able hetioner.",
      "asp": "{ action_t(TURN,oryter,THING):at_t(TURN,THING,ROOM),hetioner_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhetioner_t(TURN+1,THING) :- action_t(TURN,oryter,THING).\nhetioner_t(TURN+1,THING) :- turn(TURN), hetioner_t(TURN,THING).",
      "type_name": "oryter"
    },
    {
      "lark": "atheris: ATHERIS thing\nATHERIS.1: \"atheris\" WS",
      "pddl": "(:action ATHERIS\n    :parameters (?e - ippet_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ippet ?e)\n        )\n    :effect (and\n        (hoxopal ?e)\n        (not (ippet ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ippet-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not ippet.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now hoxopal.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To atheris is to make something ippet_able and ippet be hoxopal.",
      "asp": "{ action_t(TURN,atheris,THING):at_t(TURN,THING,ROOM),ippet_able(THING),ippet_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhoxopal_t(TURN+1,THING) :- action_t(TURN,atheris,THING).\nippet_t(TURN+1,THING) :- turn(TURN), ippet_t(TURN,THING), not action_t(TURN,atheris,THING).",
      "type_name": "atheris"
    },
    {
      "lark": "tritioush: TRITIOUSH thing\nTRITIOUSH.1: \"tritioush\" WS",
      "pddl": "(:action TRITIOUSH\n    :parameters (?e - ippet_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (hoxopal ?e)\n        )\n    :effect (and\n        (ippet ?e)\n        (not (hoxopal ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ippet-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not hoxopal.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ippet.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To tritioush is to make something ippet_able and hoxopal be ippet.",
      "asp": "{ action_t(TURN,tritioush,THING):at_t(TURN,THING,ROOM),ippet_able(THING),hoxopal_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nippet_t(TURN+1,THING) :- action_t(TURN,tritioush,THING).\nhoxopal_t(TURN+1,THING) :- turn(TURN), hoxopal_t(TURN,THING), not action_t(TURN,tritioush,THING).",
      "type_name": "tritioush"
    },
    {
      "lark": "jolene: JOLENE thing\nJOLENE.1: \"jolene\" WS",
      "pddl": "(:action JOLENE\n    :parameters (?e - tubilly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (tubilly ?e)\n        )\n    :effect (and\n        (phorpiced ?e)\n        (not (tubilly ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not tubilly-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not tubilly.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now phorpiced.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To jolene is to make something tubilly_able and tubilly be phorpiced.",
      "asp": "{ action_t(TURN,jolene,THING):at_t(TURN,THING,ROOM),tubilly_able(THING),tubilly_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nphorpiced_t(TURN+1,THING) :- action_t(TURN,jolene,THING).\ntubilly_t(TURN+1,THING) :- turn(TURN), tubilly_t(TURN,THING), not action_t(TURN,jolene,THING).",
      "type_name": "jolene"
    },
    {
      "lark": "amyoid: AMYOID thing\nAMYOID.1: \"amyoid\" WS",
      "pddl": "(:action AMYOID\n    :parameters (?e - tubilly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (phorpiced ?e)\n        )\n    :effect (and\n        (alidow ?e)\n        (not (phorpiced ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not tubilly-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not phorpiced.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now alidow.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To amyoid is to make something tubilly_able and phorpiced be alidow.",
      "asp": "{ action_t(TURN,amyoid,THING):at_t(TURN,THING,ROOM),tubilly_able(THING),phorpiced_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nalidow_t(TURN+1,THING) :- action_t(TURN,amyoid,THING).\nphorpiced_t(TURN+1,THING) :- turn(TURN), phorpiced_t(TURN,THING), not action_t(TURN,amyoid,THING).",
      "type_name": "amyoid"
    },
    {
      "lark": "urseum: URSEUM thing\nURSEUM.1: \"urseum\" WS",
      "pddl": "(:action URSEUM\n    :parameters (?e - tubilly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (alidow ?e)\n        )\n    :effect (and\n        (tubilly ?e)\n        (not (alidow ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not tubilly-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not alidow.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now tubilly.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To urseum is to make something tubilly_able and alidow be tubilly.",
      "asp": "{ action_t(TURN,urseum,THING):at_t(TURN,THING,ROOM),tubilly_able(THING),alidow_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntubilly_t(TURN+1,THING) :- action_t(TURN,urseum,THING).\nalidow_t(TURN+1,THING) :- turn(TURN), alidow_t(TURN,THING), not action_t(TURN,urseum,THING).",
      "type_name": "urseum"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "oidemat",
      "exit_targets": [
        "menzinee",
        "chlove"
      ],
      "max_connections": 1,
      "type_name": "oidemat"
    },
    {
      "repr_str": "chlove",
      "exit_targets": [
        "oidemat"
      ],
      "max_connections": 3,
      "type_name": "chlove"
    },
    {
      "repr_str": "menzinee",
      "exit_targets": [
        "chlove",
        "endroust"
      ],
      "max_connections": 2,
      "type_name": "menzinee"
    },
    {
      "repr_str": "endroust",
      "exit_targets": [
        "menzinee",
        "chlove",
        "oidemat"
      ],
      "max_connections": 2,
      "type_name": "endroust"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "utist",
      "traits": [
        "hetioner_able"
      ],
      "standard_locations": [
        "chlove",
        "endroust"
      ],
      "type_name": "utist"
    },
    {
      "repr_str": "linkly",
      "traits": [
        "hetioner_able"
      ],
      "standard_locations": [
        "oidemat"
      ],
      "type_name": "linkly"
    },
    {
      "repr_str": "anonaticed",
      "traits": [
        "ippet_able",
        "hetioner_able"
      ],
      "standard_locations": [
        "endroust",
        "menzinee"
      ],
      "type_name": "anonaticed"
    },
    {
      "repr_str": "coepticed",
      "traits": [
        "ippet_able",
        "tubilly_able"
      ],
      "standard_locations": [
        "endroust"
      ],
      "type_name": "coepticed"
    },
    {
      "repr_str": "atedist",
      "traits": [
        "ippet_able",
        "hetioner_able"
      ],
      "standard_locations": [
        "endroust",
        "chlove"
      ],
      "type_name": "atedist"
    },
    {
      "repr_str": "stoaced",
      "traits": [
        "ippet_able"
      ],
      "standard_locations": [
        "oidemat",
        "endroust"
      ],
      "type_name": "stoaced"
    },
    {
      "repr_str": "lableve",
      "traits": [
        "ippet_able"
      ],
      "standard_locations": [
        "endroust"
      ],
      "type_name": "lableve"
    },
    {
      "repr_str": "icess",
      "traits": [
        "tubilly_able",
        "hetioner_able"
      ],
      "standard_locations": [
        "endroust"
      ],
      "type_name": "icess"
    },
    {
      "repr_str": "robve",
      "traits": [
        "hetioner_able",
        "ippet_able"
      ],
      "standard_locations": [
        "chlove"
      ],
      "type_name": "robve"
    },
    {
      "repr_str": "obilard",
      "traits": [
        "tubilly_able"
      ],
      "standard_locations": [
        "oidemat",
        "menzinee"
      ],
      "type_name": "obilard"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "oidemat",
          "chlove",
          "menzinee",
          "endroust"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "utist",
          "linkly",
          "anonaticed",
          "coepticed",
          "atedist",
          "stoaced",
          "lableve",
          "icess",
          "robve",
          "obilard",
          "player",
          "inventory",
          "floor"
        ],
        "hetioner_able": [
          "utist",
          "linkly",
          "anonaticed",
          "atedist",
          "icess",
          "robve"
        ],
        "ippet_able": [
          "anonaticed",
          "coepticed",
          "atedist",
          "stoaced",
          "lableve",
          "robve"
        ],
        "tubilly_able": [
          "coepticed",
          "icess",
          "obilard"
        ]
      },
      "predicates": [
        {
          "predicate_id": "hetioner",
          "variable": "e",
          "mutability": "hetioner_able"
        },
        {
          "predicate_id": "ippet",
          "variable": "e",
          "mutability": "ippet_able"
        },
        {
          "predicate_id": "hoxopal",
          "variable": "e",
          "mutability": "ippet_able"
        },
        {
          "predicate_id": "tubilly",
          "variable": "e",
          "mutability": "tubilly_able"
        },
        {
          "predicate_id": "phorpiced",
          "variable": "e",
          "mutability": "tubilly_able"
        },
        {
          "predicate_id": "alidow",
          "variable": "e",
          "mutability": "tubilly_able"
        }
      ]
    }
  ]
}