{
  "game_id": 10,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can udial, aterous, ingnus, ivess, ceorid and unmastic.\n\nYour goal for this game is: Make the pholoiced connone, the aeval proggiced and the rheably exsem.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(ousles1,erove1)",
    "at(roofid1,omenan1)",
    "at(pholoiced1,peroury1)",
    "at(shromen1,peroury1)",
    "at(eical1,peroury1)",
    "at(oidess1,peroury1)",
    "at(versch1,peroury1)",
    "at(rheably1,apsing1)",
    "at(soest1,erove1)",
    "at(aeval1,peroury1)",
    "at(player1,peroury1)",
    "type(player1,player)",
    "type(aeval1,aeval)",
    "type(soest1,soest)",
    "type(rheably1,rheably)",
    "type(versch1,versch)",
    "type(oidess1,oidess)",
    "type(eical1,eical)",
    "type(shromen1,shromen)",
    "type(pholoiced1,pholoiced)",
    "type(roofid1,roofid)",
    "type(ousles1,ousles)",
    "room(erove1,erove)",
    "room(omenan1,omenan)",
    "room(apsing1,apsing)",
    "room(peroury1,peroury)",
    "exsem(roofid1)",
    "exsem(shromen1)",
    "exsem(eical1)",
    "exsem(oidess1)",
    "thighth(versch1)",
    "thighth(rheably1)",
    "connone(ousles1)",
    "dingnessy(versch1)",
    "alomeny(pholoiced1)",
    "exit(erove1,omenan1)",
    "exit(omenan1,erove1)",
    "exit(apsing1,omenan1)",
    "exit(peroury1,erove1)",
    "exit(erove1,peroury1)",
    "exit(omenan1,apsing1)",
    "proggiced_able(aeval1)",
    "proggiced_able(soest1)",
    "proggiced_able(rheably1)",
    "proggiced_able(oidess1)",
    "proggiced_able(pholoiced1)",
    "proggiced_able(roofid1)",
    "exsem_able(rheably1)",
    "exsem_able(versch1)",
    "exsem_able(oidess1)",
    "exsem_able(eical1)",
    "exsem_able(shromen1)",
    "exsem_able(roofid1)",
    "connone_able(versch1)",
    "connone_able(pholoiced1)",
    "connone_able(ousles1)"
  ],
  "goal_state": [
    "proggiced(aeval1)",
    "exsem(rheably1)",
    "connone(pholoiced1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "udial",
      "aeval1"
    ],
    [
      "aterous",
      "pholoiced1"
    ],
    [
      "go",
      "erove1"
    ],
    [
      "go",
      "omenan1"
    ],
    [
      "go",
      "apsing1"
    ],
    [
      "unmastic",
      "rheably1"
    ]
  ],
  "optimal_commands": [
    "udial aeval",
    "aterous pholoiced",
    "go erove",
    "go omenan",
    "go apsing",
    "unmastic rheably"
  ],
  "action_definitions": [
    {
      "lark": "udial: UDIAL thing\nUDIAL.1: \"udial\" WS",
      "pddl": "(:action UDIAL\n    :parameters (?e - proggiced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (proggiced ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not proggiced-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now proggiced.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To udial is to make something proggiced_able proggiced.",
      "asp": "{ action_t(TURN,udial,THING):at_t(TURN,THING,ROOM),proggiced_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nproggiced_t(TURN+1,THING) :- action_t(TURN,udial,THING).\nproggiced_t(TURN+1,THING) :- turn(TURN), proggiced_t(TURN,THING).",
      "type_name": "udial"
    },
    {
      "lark": "ivess: IVESS thing\nIVESS.1: \"ivess\" WS",
      "pddl": "(:action IVESS\n    :parameters (?e - exsem_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (exsem ?e)\n        )\n    :effect (and\n        (thighth ?e)\n        (not (exsem ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not exsem-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not exsem.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now thighth.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ivess is to make something exsem_able and exsem be thighth.",
      "asp": "{ action_t(TURN,ivess,THING):at_t(TURN,THING,ROOM),exsem_able(THING),exsem_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nthighth_t(TURN+1,THING) :- action_t(TURN,ivess,THING).\nexsem_t(TURN+1,THING) :- turn(TURN), exsem_t(TURN,THING), not action_t(TURN,ivess,THING).",
      "type_name": "ivess"
    },
    {
      "lark": "unmastic: UNMASTIC thing\nUNMASTIC.1: \"unmastic\" WS",
      "pddl": "(:action UNMASTIC\n    :parameters (?e - exsem_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (thighth ?e)\n        )\n    :effect (and\n        (exsem ?e)\n        (not (thighth ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not exsem-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not thighth.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now exsem.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To unmastic is to make something exsem_able and thighth be exsem.",
      "asp": "{ action_t(TURN,unmastic,THING):at_t(TURN,THING,ROOM),exsem_able(THING),thighth_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nexsem_t(TURN+1,THING) :- action_t(TURN,unmastic,THING).\nthighth_t(TURN+1,THING) :- turn(TURN), thighth_t(TURN,THING), not action_t(TURN,unmastic,THING).",
      "type_name": "unmastic"
    },
    {
      "lark": "ceorid: CEORID thing\nCEORID.1: \"ceorid\" WS",
      "pddl": "(:action CEORID\n    :parameters (?e - connone_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (connone ?e)\n        )\n    :effect (and\n        (dingnessy ?e)\n        (not (connone ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not connone-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not connone.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now dingnessy.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ceorid is to make something connone_able and connone be dingnessy.",
      "asp": "{ action_t(TURN,ceorid,THING):at_t(TURN,THING,ROOM),connone_able(THING),connone_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndingnessy_t(TURN+1,THING) :- action_t(TURN,ceorid,THING).\nconnone_t(TURN+1,THING) :- turn(TURN), connone_t(TURN,THING), not action_t(TURN,ceorid,THING).",
      "type_name": "ceorid"
    },
    {
      "lark": "ingnus: INGNUS thing\nINGNUS.1: \"ingnus\" WS",
      "pddl": "(:action INGNUS\n    :parameters (?e - connone_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (dingnessy ?e)\n        )\n    :effect (and\n        (alomeny ?e)\n        (not (dingnessy ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not connone-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not dingnessy.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now alomeny.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ingnus is to make something connone_able and dingnessy be alomeny.",
      "asp": "{ action_t(TURN,ingnus,THING):at_t(TURN,THING,ROOM),connone_able(THING),dingnessy_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nalomeny_t(TURN+1,THING) :- action_t(TURN,ingnus,THING).\ndingnessy_t(TURN+1,THING) :- turn(TURN), dingnessy_t(TURN,THING), not action_t(TURN,ingnus,THING).",
      "type_name": "ingnus"
    },
    {
      "lark": "aterous: ATEROUS thing\nATEROUS.1: \"aterous\" WS",
      "pddl": "(:action ATEROUS\n    :parameters (?e - connone_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (alomeny ?e)\n        )\n    :effect (and\n        (connone ?e)\n        (not (alomeny ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not connone-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not alomeny.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now connone.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To aterous is to make something connone_able and alomeny be connone.",
      "asp": "{ action_t(TURN,aterous,THING):at_t(TURN,THING,ROOM),connone_able(THING),alomeny_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nconnone_t(TURN+1,THING) :- action_t(TURN,aterous,THING).\nalomeny_t(TURN+1,THING) :- turn(TURN), alomeny_t(TURN,THING), not action_t(TURN,aterous,THING).",
      "type_name": "aterous"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "erove",
      "exit_targets": [
        "apsing",
        "omenan"
      ],
      "max_connections": 1,
      "type_name": "erove"
    },
    {
      "repr_str": "omenan",
      "exit_targets": [
        "erove"
      ],
      "max_connections": 3,
      "type_name": "omenan"
    },
    {
      "repr_str": "apsing",
      "exit_targets": [
        "omenan",
        "peroury"
      ],
      "max_connections": 2,
      "type_name": "apsing"
    },
    {
      "repr_str": "peroury",
      "exit_targets": [
        "apsing",
        "omenan",
        "erove"
      ],
      "max_connections": 2,
      "type_name": "peroury"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "aeval",
      "traits": [
        "proggiced_able"
      ],
      "standard_locations": [
        "omenan",
        "peroury"
      ],
      "type_name": "aeval"
    },
    {
      "repr_str": "soest",
      "traits": [
        "proggiced_able"
      ],
      "standard_locations": [
        "erove"
      ],
      "type_name": "soest"
    },
    {
      "repr_str": "rheably",
      "traits": [
        "exsem_able",
        "proggiced_able"
      ],
      "standard_locations": [
        "peroury",
        "apsing"
      ],
      "type_name": "rheably"
    },
    {
      "repr_str": "versch",
      "traits": [
        "exsem_able",
        "connone_able"
      ],
      "standard_locations": [
        "peroury"
      ],
      "type_name": "versch"
    },
    {
      "repr_str": "oidess",
      "traits": [
        "exsem_able",
        "proggiced_able"
      ],
      "standard_locations": [
        "peroury",
        "omenan"
      ],
      "type_name": "oidess"
    },
    {
      "repr_str": "eical",
      "traits": [
        "exsem_able"
      ],
      "standard_locations": [
        "erove",
        "peroury"
      ],
      "type_name": "eical"
    },
    {
      "repr_str": "shromen",
      "traits": [
        "exsem_able"
      ],
      "standard_locations": [
        "peroury"
      ],
      "type_name": "shromen"
    },
    {
      "repr_str": "pholoiced",
      "traits": [
        "connone_able",
        "proggiced_able"
      ],
      "standard_locations": [
        "peroury"
      ],
      "type_name": "pholoiced"
    },
    {
      "repr_str": "roofid",
      "traits": [
        "proggiced_able",
        "exsem_able"
      ],
      "standard_locations": [
        "omenan"
      ],
      "type_name": "roofid"
    },
    {
      "repr_str": "ousles",
      "traits": [
        "connone_able"
      ],
      "standard_locations": [
        "erove",
        "apsing"
      ],
      "type_name": "ousles"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "erove",
          "omenan",
          "apsing",
          "peroury"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "aeval",
          "soest",
          "rheably",
          "versch",
          "oidess",
          "eical",
          "shromen",
          "pholoiced",
          "roofid",
          "ousles",
          "player",
          "inventory",
          "floor"
        ],
        "proggiced_able": [
          "aeval",
          "soest",
          "rheably",
          "oidess",
          "pholoiced",
          "roofid"
        ],
        "exsem_able": [
          "rheably",
          "versch",
          "oidess",
          "eical",
          "shromen",
          "roofid"
        ],
        "connone_able": [
          "versch",
          "pholoiced",
          "ousles"
        ]
      },
      "predicates": [
        {
          "predicate_id": "proggiced",
          "variable": "e",
          "mutability": "proggiced_able"
        },
        {
          "predicate_id": "exsem",
          "variable": "e",
          "mutability": "exsem_able"
        },
        {
          "predicate_id": "thighth",
          "variable": "e",
          "mutability": "exsem_able"
        },
        {
          "predicate_id": "connone",
          "variable": "e",
          "mutability": "connone_able"
        },
        {
          "predicate_id": "dingnessy",
          "variable": "e",
          "mutability": "connone_able"
        },
        {
          "predicate_id": "alomeny",
          "variable": "e",
          "mutability": "connone_able"
        }
      ]
    }
  ]
}