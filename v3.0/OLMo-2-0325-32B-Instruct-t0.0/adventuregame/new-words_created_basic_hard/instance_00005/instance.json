{
  "game_id": 5,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can erack, plecon, lowal, icalit, cretia and crury.\n\nYour goal for this game is: Make the eprour reging, the siaticed degra and the piesm ricke.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(taillag1,lablent1)",
    "at(dergal1,tworia1)",
    "at(siaticed1,lon1)",
    "at(riack1,lon1)",
    "at(astont1,lon1)",
    "at(orele1,lon1)",
    "at(teming1,lon1)",
    "at(piesm1,lispe1)",
    "at(iless1,lablent1)",
    "at(eprour1,lon1)",
    "at(player1,lon1)",
    "type(player1,player)",
    "type(eprour1,eprour)",
    "type(iless1,iless)",
    "type(piesm1,piesm)",
    "type(teming1,teming)",
    "type(orele1,orele)",
    "type(astont1,astont)",
    "type(riack1,riack)",
    "type(siaticed1,siaticed)",
    "type(dergal1,dergal)",
    "type(taillag1,taillag)",
    "room(lablent1,lablent)",
    "room(tworia1,tworia)",
    "room(lispe1,lispe)",
    "room(lon1,lon)",
    "ricke(dergal1)",
    "ricke(riack1)",
    "ricke(astont1)",
    "ricke(orele1)",
    "ricary(teming1)",
    "ricary(piesm1)",
    "degra(taillag1)",
    "babile(teming1)",
    "scidian(siaticed1)",
    "exit(lablent1,tworia1)",
    "exit(tworia1,lablent1)",
    "exit(lispe1,tworia1)",
    "exit(lon1,lablent1)",
    "exit(lablent1,lon1)",
    "exit(tworia1,lispe1)",
    "reging_able(eprour1)",
    "reging_able(iless1)",
    "reging_able(piesm1)",
    "reging_able(orele1)",
    "reging_able(siaticed1)",
    "reging_able(dergal1)",
    "ricke_able(piesm1)",
    "ricke_able(teming1)",
    "ricke_able(orele1)",
    "ricke_able(astont1)",
    "ricke_able(riack1)",
    "ricke_able(dergal1)",
    "degra_able(teming1)",
    "degra_able(siaticed1)",
    "degra_able(taillag1)"
  ],
  "goal_state": [
    "reging(eprour1)",
    "ricke(piesm1)",
    "degra(siaticed1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "cretia",
      "eprour1"
    ],
    [
      "erack",
      "siaticed1"
    ],
    [
      "go",
      "lablent1"
    ],
    [
      "go",
      "tworia1"
    ],
    [
      "go",
      "lispe1"
    ],
    [
      "icalit",
      "piesm1"
    ]
  ],
  "optimal_commands": [
    "cretia eprour",
    "erack siaticed",
    "go lablent",
    "go tworia",
    "go lispe",
    "icalit piesm"
  ],
  "action_definitions": [
    {
      "lark": "cretia: CRETIA thing\nCRETIA.1: \"cretia\" WS",
      "pddl": "(:action CRETIA\n    :parameters (?e - reging_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (reging ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not reging-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now reging.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To cretia is to make something reging_able reging.",
      "asp": "{ action_t(TURN,cretia,THING):at_t(TURN,THING,ROOM),reging_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nreging_t(TURN+1,THING) :- action_t(TURN,cretia,THING).\nreging_t(TURN+1,THING) :- turn(TURN), reging_t(TURN,THING).",
      "type_name": "cretia"
    },
    {
      "lark": "crury: CRURY thing\nCRURY.1: \"crury\" WS",
      "pddl": "(:action CRURY\n    :parameters (?e - ricke_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ricke ?e)\n        )\n    :effect (and\n        (ricary ?e)\n        (not (ricke ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ricke-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not ricke.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ricary.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To crury is to make something ricke_able and ricke be ricary.",
      "asp": "{ action_t(TURN,crury,THING):at_t(TURN,THING,ROOM),ricke_able(THING),ricke_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nricary_t(TURN+1,THING) :- action_t(TURN,crury,THING).\nricke_t(TURN+1,THING) :- turn(TURN), ricke_t(TURN,THING), not action_t(TURN,crury,THING).",
      "type_name": "crury"
    },
    {
      "lark": "icalit: ICALIT thing\nICALIT.1: \"icalit\" WS",
      "pddl": "(:action ICALIT\n    :parameters (?e - ricke_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ricary ?e)\n        )\n    :effect (and\n        (ricke ?e)\n        (not (ricary ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not ricke-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not ricary.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now ricke.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To icalit is to make something ricke_able and ricary be ricke.",
      "asp": "{ action_t(TURN,icalit,THING):at_t(TURN,THING,ROOM),ricke_able(THING),ricary_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nricke_t(TURN+1,THING) :- action_t(TURN,icalit,THING).\nricary_t(TURN+1,THING) :- turn(TURN), ricary_t(TURN,THING), not action_t(TURN,icalit,THING).",
      "type_name": "icalit"
    },
    {
      "lark": "lowal: LOWAL thing\nLOWAL.1: \"lowal\" WS",
      "pddl": "(:action LOWAL\n    :parameters (?e - degra_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (degra ?e)\n        )\n    :effect (and\n        (babile ?e)\n        (not (degra ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not degra-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not degra.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now babile.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To lowal is to make something degra_able and degra be babile.",
      "asp": "{ action_t(TURN,lowal,THING):at_t(TURN,THING,ROOM),degra_able(THING),degra_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nbabile_t(TURN+1,THING) :- action_t(TURN,lowal,THING).\ndegra_t(TURN+1,THING) :- turn(TURN), degra_t(TURN,THING), not action_t(TURN,lowal,THING).",
      "type_name": "lowal"
    },
    {
      "lark": "plecon: PLECON thing\nPLECON.1: \"plecon\" WS",
      "pddl": "(:action PLECON\n    :parameters (?e - degra_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (babile ?e)\n        )\n    :effect (and\n        (scidian ?e)\n        (not (babile ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not degra-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not babile.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now scidian.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To plecon is to make something degra_able and babile be scidian.",
      "asp": "{ action_t(TURN,plecon,THING):at_t(TURN,THING,ROOM),degra_able(THING),babile_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nscidian_t(TURN+1,THING) :- action_t(TURN,plecon,THING).\nbabile_t(TURN+1,THING) :- turn(TURN), babile_t(TURN,THING), not action_t(TURN,plecon,THING).",
      "type_name": "plecon"
    },
    {
      "lark": "erack: ERACK thing\nERACK.1: \"erack\" WS",
      "pddl": "(:action ERACK\n    :parameters (?e - degra_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (scidian ?e)\n        )\n    :effect (and\n        (degra ?e)\n        (not (scidian ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not degra-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not scidian.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now degra.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To erack is to make something degra_able and scidian be degra.",
      "asp": "{ action_t(TURN,erack,THING):at_t(TURN,THING,ROOM),degra_able(THING),scidian_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndegra_t(TURN+1,THING) :- action_t(TURN,erack,THING).\nscidian_t(TURN+1,THING) :- turn(TURN), scidian_t(TURN,THING), not action_t(TURN,erack,THING).",
      "type_name": "erack"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "lablent",
      "exit_targets": [
        "lispe",
        "tworia"
      ],
      "max_connections": 1,
      "type_name": "lablent"
    },
    {
      "repr_str": "tworia",
      "exit_targets": [
        "lablent"
      ],
      "max_connections": 3,
      "type_name": "tworia"
    },
    {
      "repr_str": "lispe",
      "exit_targets": [
        "tworia",
        "lon"
      ],
      "max_connections": 2,
      "type_name": "lispe"
    },
    {
      "repr_str": "lon",
      "exit_targets": [
        "lispe",
        "tworia",
        "lablent"
      ],
      "max_connections": 2,
      "type_name": "lon"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "eprour",
      "traits": [
        "reging_able"
      ],
      "standard_locations": [
        "tworia",
        "lon"
      ],
      "type_name": "eprour"
    },
    {
      "repr_str": "iless",
      "traits": [
        "reging_able"
      ],
      "standard_locations": [
        "lablent"
      ],
      "type_name": "iless"
    },
    {
      "repr_str": "piesm",
      "traits": [
        "ricke_able",
        "reging_able"
      ],
      "standard_locations": [
        "lon",
        "lispe"
      ],
      "type_name": "piesm"
    },
    {
      "repr_str": "teming",
      "traits": [
        "ricke_able",
        "degra_able"
      ],
      "standard_locations": [
        "lon"
      ],
      "type_name": "teming"
    },
    {
      "repr_str": "orele",
      "traits": [
        "ricke_able",
        "reging_able"
      ],
      "standard_locations": [
        "lon",
        "tworia"
      ],
      "type_name": "orele"
    },
    {
      "repr_str": "astont",
      "traits": [
        "ricke_able"
      ],
      "standard_locations": [
        "lablent",
        "lon"
      ],
      "type_name": "astont"
    },
    {
      "repr_str": "riack",
      "traits": [
        "ricke_able"
      ],
      "standard_locations": [
        "lon"
      ],
      "type_name": "riack"
    },
    {
      "repr_str": "siaticed",
      "traits": [
        "degra_able",
        "reging_able"
      ],
      "standard_locations": [
        "lon"
      ],
      "type_name": "siaticed"
    },
    {
      "repr_str": "dergal",
      "traits": [
        "reging_able",
        "ricke_able"
      ],
      "standard_locations": [
        "tworia"
      ],
      "type_name": "dergal"
    },
    {
      "repr_str": "taillag",
      "traits": [
        "degra_able"
      ],
      "standard_locations": [
        "lablent",
        "lispe"
      ],
      "type_name": "taillag"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "lablent",
          "tworia",
          "lispe",
          "lon"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "eprour",
          "iless",
          "piesm",
          "teming",
          "orele",
          "astont",
          "riack",
          "siaticed",
          "dergal",
          "taillag",
          "player",
          "inventory",
          "floor"
        ],
        "reging_able": [
          "eprour",
          "iless",
          "piesm",
          "orele",
          "siaticed",
          "dergal"
        ],
        "ricke_able": [
          "piesm",
          "teming",
          "orele",
          "astont",
          "riack",
          "dergal"
        ],
        "degra_able": [
          "teming",
          "siaticed",
          "taillag"
        ]
      },
      "predicates": [
        {
          "predicate_id": "reging",
          "variable": "e",
          "mutability": "reging_able"
        },
        {
          "predicate_id": "ricke",
          "variable": "e",
          "mutability": "ricke_able"
        },
        {
          "predicate_id": "ricary",
          "variable": "e",
          "mutability": "ricke_able"
        },
        {
          "predicate_id": "degra",
          "variable": "e",
          "mutability": "degra_able"
        },
        {
          "predicate_id": "babile",
          "variable": "e",
          "mutability": "degra_able"
        },
        {
          "predicate_id": "scidian",
          "variable": "e",
          "mutability": "degra_able"
        }
      ]
    }
  ]
}