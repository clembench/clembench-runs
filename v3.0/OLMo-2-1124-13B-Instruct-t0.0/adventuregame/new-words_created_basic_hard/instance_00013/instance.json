{
  "game_id": 13,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can alitst, lophante, rhypnon, ophabor, ompous and hoadve.\n\nYour goal for this game is: Make the rakeer skenic, the asceles tinhal and the mituark mationymb.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(mementiced1,trapseng1)",
    "at(untastion1,ammidiced1)",
    "at(mituark1,heccop1)",
    "at(otioct1,heccop1)",
    "at(inagness1,heccop1)",
    "at(horbact1,heccop1)",
    "at(ctaticed1,heccop1)",
    "at(rakeer1,nontroust1)",
    "at(cenotor1,trapseng1)",
    "at(asceles1,heccop1)",
    "at(player1,heccop1)",
    "type(player1,player)",
    "type(asceles1,asceles)",
    "type(cenotor1,cenotor)",
    "type(rakeer1,rakeer)",
    "type(ctaticed1,ctaticed)",
    "type(horbact1,horbact)",
    "type(inagness1,inagness)",
    "type(otioct1,otioct)",
    "type(mituark1,mituark)",
    "type(untastion1,untastion)",
    "type(mementiced1,mementiced)",
    "room(trapseng1,trapseng)",
    "room(ammidiced1,ammidiced)",
    "room(nontroust1,nontroust)",
    "room(heccop1,heccop)",
    "skenic(untastion1)",
    "skenic(otioct1)",
    "skenic(inagness1)",
    "skenic(horbact1)",
    "icarity(ctaticed1)",
    "icarity(rakeer1)",
    "mationymb(mementiced1)",
    "bactiogy(ctaticed1)",
    "trendol(mituark1)",
    "exit(trapseng1,ammidiced1)",
    "exit(ammidiced1,trapseng1)",
    "exit(nontroust1,ammidiced1)",
    "exit(heccop1,trapseng1)",
    "exit(trapseng1,heccop1)",
    "exit(ammidiced1,nontroust1)",
    "tinhal_able(asceles1)",
    "tinhal_able(cenotor1)",
    "tinhal_able(rakeer1)",
    "tinhal_able(horbact1)",
    "tinhal_able(mituark1)",
    "tinhal_able(untastion1)",
    "skenic_able(rakeer1)",
    "skenic_able(ctaticed1)",
    "skenic_able(horbact1)",
    "skenic_able(inagness1)",
    "skenic_able(otioct1)",
    "skenic_able(untastion1)",
    "mationymb_able(ctaticed1)",
    "mationymb_able(mituark1)",
    "mationymb_able(mementiced1)"
  ],
  "goal_state": [
    "tinhal(asceles1)",
    "skenic(rakeer1)",
    "mationymb(mituark1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "lophante",
      "asceles1"
    ],
    [
      "rhypnon",
      "mituark1"
    ],
    [
      "go",
      "trapseng1"
    ],
    [
      "go",
      "ammidiced1"
    ],
    [
      "go",
      "nontroust1"
    ],
    [
      "hoadve",
      "rakeer1"
    ]
  ],
  "optimal_commands": [
    "lophante asceles",
    "rhypnon mituark",
    "go trapseng",
    "go ammidiced",
    "go nontroust",
    "hoadve rakeer"
  ],
  "action_definitions": [
    {
      "lark": "lophante: LOPHANTE thing\nLOPHANTE.1: \"lophante\" WS",
      "pddl": "(:action LOPHANTE\n    :parameters (?e - tinhal_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (tinhal ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not tinhal-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now tinhal.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To lophante is to make something tinhal_able tinhal.",
      "asp": "{ action_t(TURN,lophante,THING):at_t(TURN,THING,ROOM),tinhal_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntinhal_t(TURN+1,THING) :- action_t(TURN,lophante,THING).\ntinhal_t(TURN+1,THING) :- turn(TURN), tinhal_t(TURN,THING).",
      "type_name": "lophante"
    },
    {
      "lark": "alitst: ALITST thing\nALITST.1: \"alitst\" WS",
      "pddl": "(:action ALITST\n    :parameters (?e - skenic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (skenic ?e)\n        )\n    :effect (and\n        (icarity ?e)\n        (not (skenic ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not skenic-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not skenic.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now icarity.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To alitst is to make something skenic_able and skenic be icarity.",
      "asp": "{ action_t(TURN,alitst,THING):at_t(TURN,THING,ROOM),skenic_able(THING),skenic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nicarity_t(TURN+1,THING) :- action_t(TURN,alitst,THING).\nskenic_t(TURN+1,THING) :- turn(TURN), skenic_t(TURN,THING), not action_t(TURN,alitst,THING).",
      "type_name": "alitst"
    },
    {
      "lark": "hoadve: HOADVE thing\nHOADVE.1: \"hoadve\" WS",
      "pddl": "(:action HOADVE\n    :parameters (?e - skenic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (icarity ?e)\n        )\n    :effect (and\n        (skenic ?e)\n        (not (icarity ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not skenic-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not icarity.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now skenic.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To hoadve is to make something skenic_able and icarity be skenic.",
      "asp": "{ action_t(TURN,hoadve,THING):at_t(TURN,THING,ROOM),skenic_able(THING),icarity_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nskenic_t(TURN+1,THING) :- action_t(TURN,hoadve,THING).\nicarity_t(TURN+1,THING) :- turn(TURN), icarity_t(TURN,THING), not action_t(TURN,hoadve,THING).",
      "type_name": "hoadve"
    },
    {
      "lark": "ompous: OMPOUS thing\nOMPOUS.1: \"ompous\" WS",
      "pddl": "(:action OMPOUS\n    :parameters (?e - mationymb_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (mationymb ?e)\n        )\n    :effect (and\n        (bactiogy ?e)\n        (not (mationymb ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not mationymb-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not mationymb.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now bactiogy.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ompous is to make something mationymb_able and mationymb be bactiogy.",
      "asp": "{ action_t(TURN,ompous,THING):at_t(TURN,THING,ROOM),mationymb_able(THING),mationymb_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nbactiogy_t(TURN+1,THING) :- action_t(TURN,ompous,THING).\nmationymb_t(TURN+1,THING) :- turn(TURN), mationymb_t(TURN,THING), not action_t(TURN,ompous,THING).",
      "type_name": "ompous"
    },
    {
      "lark": "ophabor: OPHABOR thing\nOPHABOR.1: \"ophabor\" WS",
      "pddl": "(:action OPHABOR\n    :parameters (?e - mationymb_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (bactiogy ?e)\n        )\n    :effect (and\n        (trendol ?e)\n        (not (bactiogy ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not mationymb-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not bactiogy.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now trendol.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To ophabor is to make something mationymb_able and bactiogy be trendol.",
      "asp": "{ action_t(TURN,ophabor,THING):at_t(TURN,THING,ROOM),mationymb_able(THING),bactiogy_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntrendol_t(TURN+1,THING) :- action_t(TURN,ophabor,THING).\nbactiogy_t(TURN+1,THING) :- turn(TURN), bactiogy_t(TURN,THING), not action_t(TURN,ophabor,THING).",
      "type_name": "ophabor"
    },
    {
      "lark": "rhypnon: RHYPNON thing\nRHYPNON.1: \"rhypnon\" WS",
      "pddl": "(:action RHYPNON\n    :parameters (?e - mationymb_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (trendol ?e)\n        )\n    :effect (and\n        (mationymb ?e)\n        (not (trendol ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not mationymb-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not trendol.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now mationymb.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To rhypnon is to make something mationymb_able and trendol be mationymb.",
      "asp": "{ action_t(TURN,rhypnon,THING):at_t(TURN,THING,ROOM),mationymb_able(THING),trendol_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nmationymb_t(TURN+1,THING) :- action_t(TURN,rhypnon,THING).\ntrendol_t(TURN+1,THING) :- turn(TURN), trendol_t(TURN,THING), not action_t(TURN,rhypnon,THING).",
      "type_name": "rhypnon"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "trapseng",
      "exit_targets": [
        "nontroust",
        "ammidiced"
      ],
      "max_connections": 1,
      "type_name": "trapseng"
    },
    {
      "repr_str": "ammidiced",
      "exit_targets": [
        "trapseng"
      ],
      "max_connections": 3,
      "type_name": "ammidiced"
    },
    {
      "repr_str": "nontroust",
      "exit_targets": [
        "ammidiced",
        "heccop"
      ],
      "max_connections": 2,
      "type_name": "nontroust"
    },
    {
      "repr_str": "heccop",
      "exit_targets": [
        "nontroust",
        "ammidiced",
        "trapseng"
      ],
      "max_connections": 2,
      "type_name": "heccop"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "asceles",
      "traits": [
        "tinhal_able"
      ],
      "standard_locations": [
        "ammidiced",
        "heccop"
      ],
      "type_name": "asceles"
    },
    {
      "repr_str": "cenotor",
      "traits": [
        "tinhal_able"
      ],
      "standard_locations": [
        "trapseng"
      ],
      "type_name": "cenotor"
    },
    {
      "repr_str": "rakeer",
      "traits": [
        "skenic_able",
        "tinhal_able"
      ],
      "standard_locations": [
        "heccop",
        "nontroust"
      ],
      "type_name": "rakeer"
    },
    {
      "repr_str": "ctaticed",
      "traits": [
        "skenic_able",
        "mationymb_able"
      ],
      "standard_locations": [
        "heccop"
      ],
      "type_name": "ctaticed"
    },
    {
      "repr_str": "horbact",
      "traits": [
        "skenic_able",
        "tinhal_able"
      ],
      "standard_locations": [
        "heccop",
        "ammidiced"
      ],
      "type_name": "horbact"
    },
    {
      "repr_str": "inagness",
      "traits": [
        "skenic_able"
      ],
      "standard_locations": [
        "trapseng",
        "heccop"
      ],
      "type_name": "inagness"
    },
    {
      "repr_str": "otioct",
      "traits": [
        "skenic_able"
      ],
      "standard_locations": [
        "heccop"
      ],
      "type_name": "otioct"
    },
    {
      "repr_str": "mituark",
      "traits": [
        "mationymb_able",
        "tinhal_able"
      ],
      "standard_locations": [
        "heccop"
      ],
      "type_name": "mituark"
    },
    {
      "repr_str": "untastion",
      "traits": [
        "tinhal_able",
        "skenic_able"
      ],
      "standard_locations": [
        "ammidiced"
      ],
      "type_name": "untastion"
    },
    {
      "repr_str": "mementiced",
      "traits": [
        "mationymb_able"
      ],
      "standard_locations": [
        "trapseng",
        "nontroust"
      ],
      "type_name": "mementiced"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "trapseng",
          "ammidiced",
          "nontroust",
          "heccop"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "asceles",
          "cenotor",
          "rakeer",
          "ctaticed",
          "horbact",
          "inagness",
          "otioct",
          "mituark",
          "untastion",
          "mementiced",
          "player",
          "inventory",
          "floor"
        ],
        "tinhal_able": [
          "asceles",
          "cenotor",
          "rakeer",
          "horbact",
          "mituark",
          "untastion"
        ],
        "skenic_able": [
          "rakeer",
          "ctaticed",
          "horbact",
          "inagness",
          "otioct",
          "untastion"
        ],
        "mationymb_able": [
          "ctaticed",
          "mituark",
          "mementiced"
        ]
      },
      "predicates": [
        {
          "predicate_id": "tinhal",
          "variable": "e",
          "mutability": "tinhal_able"
        },
        {
          "predicate_id": "skenic",
          "variable": "e",
          "mutability": "skenic_able"
        },
        {
          "predicate_id": "icarity",
          "variable": "e",
          "mutability": "skenic_able"
        },
        {
          "predicate_id": "mationymb",
          "variable": "e",
          "mutability": "mationymb_able"
        },
        {
          "predicate_id": "bactiogy",
          "variable": "e",
          "mutability": "mationymb_able"
        },
        {
          "predicate_id": "trendol",
          "variable": "e",
          "mutability": "mationymb_able"
        }
      ]
    }
  ]
}