{
  "game_id": 8,
  "variant": "basic",
  "prompt": "You are playing a text adventure game. I will describe what you can perceive in the game. You write the single action you want to take in the game starting with >. Only reply with an action.\nFor example:\n> open cupboard\n\nIn addition to common actions, you can abluty, uningne, athemb, altric, polotit and arimic.\n\nYour goal for this game is: Make the chophal permity, the hooiced nionian and the nousion nophyle.\n\nOnce you have achieved your goal, write \"> done\" to end the game.\n\n",
  "initial_state": [
    "at(ditain1,itink1)",
    "at(ridism1,ambint1)",
    "at(hooiced1,hydroft1)",
    "at(glogly1,hydroft1)",
    "at(gicalio1,hydroft1)",
    "at(eleniced1,hydroft1)",
    "at(alloger1,hydroft1)",
    "at(nousion1,pledle1)",
    "at(matiorm1,itink1)",
    "at(chophal1,hydroft1)",
    "at(player1,hydroft1)",
    "type(player1,player)",
    "type(chophal1,chophal)",
    "type(matiorm1,matiorm)",
    "type(nousion1,nousion)",
    "type(alloger1,alloger)",
    "type(eleniced1,eleniced)",
    "type(gicalio1,gicalio)",
    "type(glogly1,glogly)",
    "type(hooiced1,hooiced)",
    "type(ridism1,ridism)",
    "type(ditain1,ditain)",
    "room(itink1,itink)",
    "room(ambint1,ambint)",
    "room(pledle1,pledle)",
    "room(hydroft1,hydroft)",
    "nophyle(ridism1)",
    "nophyle(glogly1)",
    "nophyle(gicalio1)",
    "nophyle(eleniced1)",
    "tursotic(alloger1)",
    "tursotic(nousion1)",
    "nionian(ditain1)",
    "irmanty(alloger1)",
    "scalike(hooiced1)",
    "exit(itink1,ambint1)",
    "exit(ambint1,itink1)",
    "exit(pledle1,ambint1)",
    "exit(hydroft1,itink1)",
    "exit(itink1,hydroft1)",
    "exit(ambint1,pledle1)",
    "permity_able(chophal1)",
    "permity_able(matiorm1)",
    "permity_able(nousion1)",
    "permity_able(eleniced1)",
    "permity_able(hooiced1)",
    "permity_able(ridism1)",
    "nophyle_able(nousion1)",
    "nophyle_able(alloger1)",
    "nophyle_able(eleniced1)",
    "nophyle_able(gicalio1)",
    "nophyle_able(glogly1)",
    "nophyle_able(ridism1)",
    "nionian_able(alloger1)",
    "nionian_able(hooiced1)",
    "nionian_able(ditain1)"
  ],
  "goal_state": [
    "permity(chophal1)",
    "nophyle(nousion1)",
    "nionian(hooiced1)"
  ],
  "max_turns": 50,
  "optimal_turns": 6,
  "optimal_solution": [
    [
      "athemb",
      "chophal1"
    ],
    [
      "arimic",
      "hooiced1"
    ],
    [
      "go",
      "itink1"
    ],
    [
      "go",
      "ambint1"
    ],
    [
      "go",
      "pledle1"
    ],
    [
      "altric",
      "nousion1"
    ]
  ],
  "optimal_commands": [
    "athemb chophal",
    "arimic hooiced",
    "go itink",
    "go ambint",
    "go pledle",
    "altric nousion"
  ],
  "action_definitions": [
    {
      "lark": "athemb: ATHEMB thing\nATHEMB.1: \"athemb\" WS",
      "pddl": "(:action ATHEMB\n    :parameters (?e - permity_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (permity ?e)\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not permity-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now permity.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To athemb is to make something permity_able permity.",
      "asp": "{ action_t(TURN,athemb,THING):at_t(TURN,THING,ROOM),permity_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npermity_t(TURN+1,THING) :- action_t(TURN,athemb,THING).\npermity_t(TURN+1,THING) :- turn(TURN), permity_t(TURN,THING).",
      "type_name": "athemb"
    },
    {
      "lark": "abluty: ABLUTY thing\nABLUTY.1: \"abluty\" WS",
      "pddl": "(:action ABLUTY\n    :parameters (?e - nophyle_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (nophyle ?e)\n        )\n    :effect (and\n        (tursotic ?e)\n        (not (nophyle ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not nophyle-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not nophyle.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now tursotic.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To abluty is to make something nophyle_able and nophyle be tursotic.",
      "asp": "{ action_t(TURN,abluty,THING):at_t(TURN,THING,ROOM),nophyle_able(THING),nophyle_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntursotic_t(TURN+1,THING) :- action_t(TURN,abluty,THING).\nnophyle_t(TURN+1,THING) :- turn(TURN), nophyle_t(TURN,THING), not action_t(TURN,abluty,THING).",
      "type_name": "abluty"
    },
    {
      "lark": "altric: ALTRIC thing\nALTRIC.1: \"altric\" WS",
      "pddl": "(:action ALTRIC\n    :parameters (?e - nophyle_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (tursotic ?e)\n        )\n    :effect (and\n        (nophyle ?e)\n        (not (tursotic ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not nophyle-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not tursotic.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now nophyle.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To altric is to make something nophyle_able and tursotic be nophyle.",
      "asp": "{ action_t(TURN,altric,THING):at_t(TURN,THING,ROOM),nophyle_able(THING),tursotic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nnophyle_t(TURN+1,THING) :- action_t(TURN,altric,THING).\ntursotic_t(TURN+1,THING) :- turn(TURN), tursotic_t(TURN,THING), not action_t(TURN,altric,THING).",
      "type_name": "altric"
    },
    {
      "lark": "uningne: UNINGNE thing\nUNINGNE.1: \"uningne\" WS",
      "pddl": "(:action UNINGNE\n    :parameters (?e - nionian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (nionian ?e)\n        )\n    :effect (and\n        (irmanty ?e)\n        (not (nionian ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not nionian-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not nionian.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now irmanty.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To uningne is to make something nionian_able and nionian be irmanty.",
      "asp": "{ action_t(TURN,uningne,THING):at_t(TURN,THING,ROOM),nionian_able(THING),nionian_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nirmanty_t(TURN+1,THING) :- action_t(TURN,uningne,THING).\nnionian_t(TURN+1,THING) :- turn(TURN), nionian_t(TURN,THING), not action_t(TURN,uningne,THING).",
      "type_name": "uningne"
    },
    {
      "lark": "polotit: POLOTIT thing\nPOLOTIT.1: \"polotit\" WS",
      "pddl": "(:action POLOTIT\n    :parameters (?e - nionian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (irmanty ?e)\n        )\n    :effect (and\n        (scalike ?e)\n        (not (irmanty ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not nionian-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not irmanty.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now scalike.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To polotit is to make something nionian_able and irmanty be scalike.",
      "asp": "{ action_t(TURN,polotit,THING):at_t(TURN,THING,ROOM),nionian_able(THING),irmanty_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nscalike_t(TURN+1,THING) :- action_t(TURN,polotit,THING).\nirmanty_t(TURN+1,THING) :- turn(TURN), irmanty_t(TURN,THING), not action_t(TURN,polotit,THING).",
      "type_name": "polotit"
    },
    {
      "lark": "arimic: ARIMIC thing\nARIMIC.1: \"arimic\" WS",
      "pddl": "(:action ARIMIC\n    :parameters (?e - nionian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (scalike ?e)\n        )\n    :effect (and\n        (nionian ?e)\n        (not (scalike ?e))\n    )\n)",
      "pddl_parameter_mapping": {
        "?e": [
          "arg1"
        ],
        "?r": [
          "current_player_room"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "The {{ e }} is not nionian-able.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "The {{ e }} is not scalike.",
            "entity_state_mismatch"
          ]
        ]
      },
      "success_feedback": "The {{ e }} is now nionian.",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To arimic is to make something nionian_able and scalike be nionian.",
      "asp": "{ action_t(TURN,arimic,THING):at_t(TURN,THING,ROOM),nionian_able(THING),scalike_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nnionian_t(TURN+1,THING) :- action_t(TURN,arimic,THING).\nscalike_t(TURN+1,THING) :- turn(TURN), scalike_t(TURN,THING), not action_t(TURN,arimic,THING).",
      "type_name": "arimic"
    },
    {
      "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
      "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
      "pddl_parameter_mapping": {
        "?c": [
          "current_player_room"
        ],
        "?d": [
          "arg1"
        ],
        "?p": [
          "player"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ c }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ d }} is not a room.",
            "domain_trait_type_mismatch"
          ],
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't go to a {{ d }} from here.",
            "no_exit_to"
          ],
          [
            "You are already in the {{ d }}.",
            "going_to_current_room"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
      "epistemic": true,
      "pragmatic": true,
      "explanation": "To VERB is to move through space, especially to a place.",
      "type_name": "go"
    },
    {
      "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
      "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "You consider yourself done.",
      "asp": "",
      "epistemic": false,
      "pragmatic": true,
      "explanation": "To VERB is to end the game.",
      "type_name": "done"
    },
    {
      "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ],
        "?e": [
          "arg1"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ e }} is not an entity. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ],
          [
            "Your inventory is not an entity. (This should not occur.)",
            "world_state_discrepancy"
          ],
          [
            "You can't see a {{ e }} here.",
            "entity_not_accessible"
          ]
        ]
      },
      "success_feedback": "{{ arg1_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to observe or inspect carefully.",
      "type_name": "examine"
    },
    {
      "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
      "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
      "pddl_parameter_mapping": {
        "?p": [
          "player"
        ],
        "?r": [
          "current_player_room"
        ]
      },
      "failure_feedback": {
        "parameters": [
          [
            "{{ p }} is not a player. (This should not occur.)",
            "domain_type_discrepancy"
          ],
          [
            "{{ r }} is not a room. (This should not occur.)",
            "domain_type_discrepancy"
          ]
        ],
        "precondition": [
          [
            "You are not where you are! (This should not occur.)",
            "world_state_discrepancy"
          ]
        ]
      },
      "success_feedback": "{{ room_desc }}",
      "asp": "",
      "epistemic": true,
      "pragmatic": false,
      "explanation": "To VERB is to inspect a room.",
      "type_name": "look"
    }
  ],
  "room_definitions": [
    {
      "repr_str": "itink",
      "exit_targets": [
        "pledle",
        "ambint"
      ],
      "max_connections": 1,
      "type_name": "itink"
    },
    {
      "repr_str": "ambint",
      "exit_targets": [
        "itink"
      ],
      "max_connections": 3,
      "type_name": "ambint"
    },
    {
      "repr_str": "pledle",
      "exit_targets": [
        "ambint",
        "hydroft"
      ],
      "max_connections": 2,
      "type_name": "pledle"
    },
    {
      "repr_str": "hydroft",
      "exit_targets": [
        "pledle",
        "ambint",
        "itink"
      ],
      "max_connections": 2,
      "type_name": "hydroft"
    }
  ],
  "entity_definitions": [
    {
      "repr_str": "chophal",
      "traits": [
        "permity_able"
      ],
      "standard_locations": [
        "ambint",
        "hydroft"
      ],
      "type_name": "chophal"
    },
    {
      "repr_str": "matiorm",
      "traits": [
        "permity_able"
      ],
      "standard_locations": [
        "itink"
      ],
      "type_name": "matiorm"
    },
    {
      "repr_str": "nousion",
      "traits": [
        "nophyle_able",
        "permity_able"
      ],
      "standard_locations": [
        "hydroft",
        "pledle"
      ],
      "type_name": "nousion"
    },
    {
      "repr_str": "alloger",
      "traits": [
        "nophyle_able",
        "nionian_able"
      ],
      "standard_locations": [
        "hydroft"
      ],
      "type_name": "alloger"
    },
    {
      "repr_str": "eleniced",
      "traits": [
        "nophyle_able",
        "permity_able"
      ],
      "standard_locations": [
        "hydroft",
        "ambint"
      ],
      "type_name": "eleniced"
    },
    {
      "repr_str": "gicalio",
      "traits": [
        "nophyle_able"
      ],
      "standard_locations": [
        "itink",
        "hydroft"
      ],
      "type_name": "gicalio"
    },
    {
      "repr_str": "glogly",
      "traits": [
        "nophyle_able"
      ],
      "standard_locations": [
        "hydroft"
      ],
      "type_name": "glogly"
    },
    {
      "repr_str": "hooiced",
      "traits": [
        "nionian_able",
        "permity_able"
      ],
      "standard_locations": [
        "hydroft"
      ],
      "type_name": "hooiced"
    },
    {
      "repr_str": "ridism",
      "traits": [
        "permity_able",
        "nophyle_able"
      ],
      "standard_locations": [
        "ambint"
      ],
      "type_name": "ridism"
    },
    {
      "repr_str": "ditain",
      "traits": [
        "nionian_able"
      ],
      "standard_locations": [
        "itink",
        "pledle"
      ],
      "type_name": "ditain"
    },
    {
      "repr_str": "you",
      "traits": [],
      "hidden": true,
      "type_name": "player"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "inventory"
    },
    {
      "repr_str": "",
      "traits": [],
      "hidden": true,
      "type_name": "floor"
    }
  ],
  "domain_definitions": [
    {
      "domain_id": "new_words",
      "types": {
        "room": [
          "itink",
          "ambint",
          "pledle",
          "hydroft"
        ],
        "entity": [
          "player",
          "inventory",
          "floor",
          "chophal",
          "matiorm",
          "nousion",
          "alloger",
          "eleniced",
          "gicalio",
          "glogly",
          "hooiced",
          "ridism",
          "ditain",
          "player",
          "inventory",
          "floor"
        ],
        "permity_able": [
          "chophal",
          "matiorm",
          "nousion",
          "eleniced",
          "hooiced",
          "ridism"
        ],
        "nophyle_able": [
          "nousion",
          "alloger",
          "eleniced",
          "gicalio",
          "glogly",
          "ridism"
        ],
        "nionian_able": [
          "alloger",
          "hooiced",
          "ditain"
        ]
      },
      "predicates": [
        {
          "predicate_id": "permity",
          "variable": "e",
          "mutability": "permity_able"
        },
        {
          "predicate_id": "nophyle",
          "variable": "e",
          "mutability": "nophyle_able"
        },
        {
          "predicate_id": "tursotic",
          "variable": "e",
          "mutability": "nophyle_able"
        },
        {
          "predicate_id": "nionian",
          "variable": "e",
          "mutability": "nionian_able"
        },
        {
          "predicate_id": "irmanty",
          "variable": "e",
          "mutability": "nionian_able"
        },
        {
          "predicate_id": "scalike",
          "variable": "e",
          "mutability": "nionian_able"
        }
      ]
    }
  ]
}